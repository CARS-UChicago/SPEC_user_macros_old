# Global variable used by these macros
global RS_SCAN_DAT
global RS_SCALE_BY_SQRT
       RS_SCALE_BY_SQRT = 1;     
global RS_CHECK_SCAN
       RS_CHECK_SCAN = 1;
global RS_SKIP_BRAGGS
       RS_SKIP_BRAGGS = 1;
global RS_BAD_SCAN_IDX 
       RS_BAD_SCAN_IDX = 0;

# Need a bad scan idx etc...  and repeat scans, check avgs etc....
# also need a better rocking scan, ie stretch the bgr ??

####################################################################
# Rod_scan.
def rod_scan '{
    # local vars for input data
    local h_val, k_val, l_st, l_en, del_l, scan_axis
    local max_cnt, l_b, del_lb 

    # local vars for scan calcs, etc...    
    local num_l_pts,F_scale, del_sign  


    # local vars for rocking scan
    local scan_range, num_scan_pts, max_rep, max_cnt 
      scan_range =  1;
      num_scan_pts = 40;
      max_rep = 5;
      min_cnt = 0.5;  # min cnt time is 1/2 sec per point

    # other misc local vars
    local msg_str, j, temp_val, l_val 
    
   
    # check input
    if ($# != 9 ) {
      msg_str = "Usage: rod_scan H K L_start L_end del_L" 
      msg_str = msg_str " Scan_Axis Max_count L_bragg Delta_Lbragg\n "
      print msg_str
      exit
    } 
    # This makes sure the scan-axis exists 
    _check0 $6


    # assign input data to local vars
    h_val = $1,  k_val = $2, l_st = $3, l_en = $4, del_l = $5; 
    scan_axis = $6, max_cnt = $7, l_b = $8, del_lb = $9;

    num_l_pts = int( (l_en - l_st)/del_l );
    del_sign = sign(num_l_pts)
    num_l_pts = 1 + (  del_sign * num_l_pts) ;
    if (num_l_pts == 1) {
        msg_str = " Error: Num points = 1 "
        print msg_str
        exit
    }
    
    # build an array for the rocking scan data
    local array RS_ARRAY[num_l_pts][6]

    ## Make an array of HKL, cnt_times, F-values and bragg flags 
    # Note F_scale sets the scale between the maximum intensity and min intensity
    # ie if F_scale = 1e3, then the max_F = 1e3 and min_F = 1e-3
    # The min_F is gaurenteed to occur at the anti-bragg point and then F will saturate
    # near the bragg point at max_F.  1e-3 seems to be a good value, since the cnt times
    # are scaled as cnt_time = min_cnt * sqrt(1/F).  Therefore if the min count time is 1sec
    # this would give cnt_time ~ 30sec at the anti-Bragg.  
    # Note we should also check to see if the L-value might result in an allowed 3rd order or 4th 
    # order reflection, if so include this as a flag in the last col of the RS_ARRAY 

    F_scale = 1e3;
  
    for (j=0;j<num_l_pts;j++) {
       bragg_flag = 0;
       RS_ARRAY[j][0] = h_val;
       RS_ARRAY[j][1] = k_val;
       RS_ARRAY[j][2] = l_val = l_st + (j)*(del_l)*(del_sign);
       RS_ARRAY[j][3] = min_cnt;
      
       temp_val = square( sin( PI*(l_val - l_b ) / del_lb ) ); 
       if (temp_val < 1/F_scale) {
             RS_ARRAY[j][4] = F_scale;
             RS_ARRAY[j][5] = 1;
       } else {
             RS_ARRAY[j][4] = (1/temp_val)/F_scale;
             RS_ARRAY[j][5] = 0;
       }  
    }

   ## Now scale the cnt times by sqrt(1/F) or 1/F 
    for (j=0;j<num_l_pts;j++) {
      if(RS_SCALE_BY_SQRT){
         RS_ARRAY[j][3]   = int( RS_ARRAY[j][3] * sqrt( 1 / RS_ARRAY[j][4] ) );
      } else {
          RS_ARRAY[j][3]   = int( RS_ARRAY[j][3] * 1 / RS_ARRAY[j][4] );
      }
      if (RS_ARRAY[j][3]   >  max_cnt) RS_ARRAY[j][3] = max_cnt;
      if (RS_ARRAY[j][3]   ==  0) RS_ARRAY[j][3] = min_cnt;
    }

 
   ## Do pre checking on the HKL range, 
   # ie can we get to all these places
   for (j=0;j<num_l_pts;j++) {
       H = RS_ARRAY[j][0]; 
       K = RS_ARRAY[j][1]; 
       L = RS_ARRAY[j][2];
       if (calcA){
          eprintf("(H K L = %g %g %g)\n",H,K,L)
          exit
       }
       _bad_lim=0; _hkl_lim
       if (_bad_lim) {
          eprintf("(H K L = %g %g %g)\n",H,K,L)
          exit
      }
   }

   
  # Print message that starting a new rod scan
    msg_str = sprintf("%s %g %g","#ROD_SCAN rod_scan", h_val, k_val);
    msg_str = sprintf("%s %g %g %g",msg_str, l_st,l_en,del_l);
    msg_str = sprintf("%s %s %g %g %g", msg_str, motor_mne(scan_axis), max_cnt, l_b, del_lb); 
    printf("\n%s\n", msg_str); 

  if (RS_CHECK_SCAN == 0) {
       # Do the scans
       # make sure the A array is updated with current values
       get_angles;    

       if (DATAFILE !=""){
              fprintf(DATAFILE,"\n%s\n", msg_str); 
       }

       for (j=0;j<num_l_pts;j++) {
           H = RS_ARRAY[j][0]; 
           K = RS_ARRAY[j][1]; 
           L = RS_ARRAY[j][2];
           scan_cnt_time = RS_ARRAY[j][3];
           if ( (RS_ARRAY[j][5] == 1) && (RS_SKIP_BRAGGS == 1) ) {
              p " ******   Skipping L = ", L, "******"
           } else {
              RS_BAD_SCAN_IDX = 1;
              while(RS_BAD_SCAN_IDX) { 
                print "br H K L" 
                print "waitmove"
                print "dscan scan_axis -1*scan_range/2 scan_range/2  scan_cnt_time"
                RS_BAD_SCAN_IDX = 0;
              }  
           }
       }

  } else {
       # check out the scan info
       local tot_time;
       tot_time = 0;
       p "test scan info"
       p "       H      K      L     cnt      F      b_flag "
       for (j=0;j<num_l_pts;j++){
           msg_str="";        
           for(k=0;k<6;k++){
            msg_str = sprintf("%s  %6.5g", msg_str, RS_ARRAY[j][k]);
           }
           tot_time = tot_time + RS_ARRAY[j][3]*num_scan_pts;
           msg_str = sprintf("%s \n", msg_str);
           p msg_str;
       }      
       p "Number of points = ", num_l_pts
       p "Estimated total time (sec) = ", tot_time 
       p "Estimated total time (min) = ", tot_time / 60 
       p "Estimated total time (hrs) = ", tot_time / 3600 
      
  }


}'

####################################################################

