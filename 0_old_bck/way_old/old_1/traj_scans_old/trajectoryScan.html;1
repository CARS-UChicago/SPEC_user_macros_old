<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="ProgId" content="Word.Document">
<meta name="Originator" content="Microsoft Word 9">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Trajectory Scanning with the Newport Diffractometer</title>
<link rel="File-List"
href="./TrajectoryScanning_files/filelist.xml">
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Mark Rivers</o:Author>
  <o:LastAuthor>Mark Rivers</o:LastAuthor>
  <o:Revision>5</o:Revision>
  <o:TotalTime>48</o:TotalTime>
  <o:Created>2000-08-10T00:47:00Z</o:Created>
  <o:LastSaved>2000-08-10T01:11:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Company>CARS</o:Company>
  <o:Lines>1</o:Lines>
  <o:Paragraphs>1</o:Paragraphs>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:Compatibility>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;}
h2
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:14.0pt;
	font-family:Arial;
	font-style:italic;}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;}
h4
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:4;
	font-size:14.0pt;
	font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:147745543;
	mso-list-type:hybrid;
	mso-list-template-ids:2028517282 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l1
	{mso-list-id:533470917;
	mso-list-type:hybrid;
	mso-list-template-ids:1569775248 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l2
	{mso-list-id:577136603;
	mso-list-type:hybrid;
	mso-list-template-ids:214329800 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l3
	{mso-list-id:1320226720;
	mso-list-type:hybrid;
	mso-list-template-ids:214329800 67698689 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l3:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
</head>

<body lang="EN-US" style="tab-interval:.5in">

<h1 align="center" style="text-align:center">Trajectory Scanning
with the Newport MM4005 Motor Controller</h1>

<h2 align="center" style="text-align:center">Mark Rivers</h2>

<h2 align="center" style="text-align:center">August 12, 2000</h2>

<h2>Contents</h2>

<ul>
    <li><a href="#Overview">Overview</a></li>
    <li><a href="#Implementation">Implementation</a></li>
    <li><a href="#Safety">Safety</a></li>
    <li><a href="#Notation">Notation</a></li>
    <li><a href="#Defining a Trajectory">Defining a Trajectory</a></li>
    <li><a href="#Building a Trajectory">Building a Trajectory</a></li>
    <li><a href="#Executing a Trajectory">Executing a Trajectory</a></li>
    <li><a href="#Reading Back a Trajectory">Reading Back a
        Trajectory</a></li>
    <li><a href="#Interaction with EPICS Motor Records">Interaction
        with EPICS Motor Records</a></li>
    <li><a href="#Communication with the MM4005">Communication
        with the MM4005</a></li>
    <li><a href="#Hardware Notes">Hardware Notes</a></li>
    <li><a href="#vxWorks startup file">vxWorks Startup File</a></li>
    <li><a href="#MEDM screens">MEDM Screens</a></li>
    <li><a href="#Example IDL Procedure">Example IDL Procedure</a></li>
</ul>

<h2><a name="Overview">Overview</a></h2>

<p class="MsoNormal">The Newport MM4005 controller is capable of
executing complex coordinated motions. At the APS the MM4005 is
primarily used to drive the large Newport diffractometer.
Trajectories can be defined which move any or all of the
diffractometer axes through any set of complex motions. The
controller will coordinate these motions, keeping each axis very
close to the theoretical position during the entire motion. The
controller can output logic pulses during the execution of the
traectory, permitting external equipment to be synchronized to
the motion. These capabilities are ideally suited to
&#147;on-the-fly&#148; data collection. For example, one could
use SPEC to compute a set of diffractometer positions for a scan
in HKL space, and then download these positions to the MM4005 and
execute the entire scan without stopping, collecting data in a
multi-channel scaler. This can reduce data collection times
dramatically relative to traditional step scanning.</p>

<p class="MsoNormal">&nbsp;</p>

<p class="MsoNormal">This document describes an EPICS interface
to the trajectory capabilities of the MM4005. This interface is
completely general for the MM4005, it is not specific to the
Newport diffractometer. The interface lets any EPICS channel
access client do the following:</p>

<ul>
    <li>Define the total number of trajectory elements</li>
    <li>Define the absolute or relative positions of each axis
        for each point in the trajectory</li>
    <li>Define the time for each element of the trajectory, or
        alternatively the total execution time with equal time
        per trajectory element</li>
    <li>Define a total time scaling factor from .01 to 100 which
        will speed up or slow down the trajectory execution
        relative to its original definition</li>
    <li>Define the total number of output synchronization pulses</li>
    <li>Define the trajectory elements where pulse outputs begin
        and end</li>
    <li>Define detector triggers to start detectors at the
        beginning of the trajectory and stop them at the end of
        the trajectory</li>
    <li>Build the trajectory, checking for completion and errors</li>
    <li>Execute the trajectory, checking for completion and
        errors. This can be done repeatedly without rebuilding if
        only the start position and/or the time scaling changes.</li>
    <li>Read back the actual positions of each axis when each
        synchronization pulse was output</li>
    <li>Read back the following errors (actual-theoretical
        positions) when each synchronization pulse was output</li>
</ul>

<h2><a name="Implementation">Implementation</a></h2>

<p class="MsoNormal">The EPICS implementation consists of the
following:</p>

<ul>
    <li>A database file, <font face="Times New Roman"><code>trajectoryScan.db.</code></font>
        This database contains almost no &#147;logic&#148; with
        no links between records in the database. The records are
        simply variables which channel access clients and the
        State Notation Language (SNL) program use.</li>
    <li>An SNL program,<font face="Times New Roman"><code>
        trajectoryScan.st. </code></font>This program implements
        all of the logic for communicating with the MM4005 and
        with channel access clients via the database.</li>
    <li>MEDM screens, <font face="Times New Roman"><code>trajectoryScan.adl,
        trajectoryScanDebug.adl, trajectoryPlot.adl</code></font>.
        These screens are used to control the building,
        execution, readback, debugging and plotting of trajectory
        scans.</li>
</ul>

<p>&nbsp;</p>

<h2><a name="Safety">Safety</a></h2>

<p>The MM4005 is primarily used at the APS to control the large
Newport diffractometer. This device is capable of moving large
masses at high speeds. The trajectory scanning software does not
use the EPICS motor record, and so does not obey any software
limits defined in the motor record. It is very important that:</p>

<ul>
    <li>The MM4005 be programmed via the front panel to have safe
        software limits to prevent collisions whenever possible.
        The trajectory scanning software does obey the MM4005
        internal soft limits.</li>
    <li>Care be taken to avoid trajectory execution whenever
        personnel could be harmed. The following error thresholds
        for each axis on the MM4005 should be set tight enough
        that the motor power will turn off when a significant
        resistance is met. An emergency stop button should be
        within reach whenever personnel are working on the
        diffractometer, and the switch should be in the Stop
        position whenever personnel are working for extended
        periods or in vulnerable positions on the diffractometer.</li>
</ul>

<p>&nbsp;</p>

<h2><a name="Notation">Notation</a></h2>

<p>The database is loaded with $(P) (prefix) and $(R) (record
base) macros. For example, $(P) might be 13IDC: for the name of
the IOC, and $(R) might be Traj1: for the first trajectory in
this IOC. The prefixes are omitted from the Process Variable (PV)
names in this document, but one should be aware that, for
example, NElements is really $(P)$(R)NElements or in this case
13IDC:Traj1:NElements.</p>

<p>There are 8 motors in the database, and thus 8 similar records
for many functions. For example, the records defining the
trajectory positions are M1Traj, M2Traj ... M8Traj. These are
referred to in this document either are M1Traj ... M8Traj or as
MnTraj.</p>

<p>&nbsp;</p>

<h2><a name="Defining a Trajectory">Defining a Trajectory</a></h2>

<p>The MM4005 always defines a trajectory in terms of
displacements (i.e. relative positions) of each motor for each
element of the trajectory. Each trajectory element has an
execution time associated with it, and hence there is a velocity
defined for each motor (displacement/time) for each trajectory
element. The MM4005 supports trajectories of up to 2000 elements.</p>

<p>The following table lists the EPICS Process Variables (PVs)
are used to define the trajectory. Some of these are explained in
more detail below.</p>

<table border="1">
    <tr>
        <td><strong>PV Name</strong></td>
        <td><strong>Record Type</strong></td>
        <td><strong>Description</strong></td>
    </tr>
    <tr>
        <td>NumAxes</td>
        <td>longout</td>
        <td>The number of motors (axes) which are connected to
        the MM4005. Normally 6 for the MM4005 driving the
        diffractometer goniometer and 8 for the MM4005 driving
        the diffractometer base and sample stage. Default defined
        when database is loaded.</td>
    </tr>
    <tr>
        <td>NElements</td>
        <td>longout</td>
        <td>The number of elements in the trajectory, i.e. the
        number of valid points in the M1Traj...M8Traj and
        TimeTraj arrays. Default=1.</td>
    </tr>
    <tr>
        <td>MoveMode</td>
        <td>mbbi</td>
        <td>Defines the type of position information contained in
        M1Traj...M8Traj. Relative, Absolute or Hydrid.
        Default=Relative.</td>
    </tr>
    <tr>
        <td>M1Traj ... M8Traj</td>
        <td>waveform, double</td>
        <td>The displacements or absolute positions of each motor
        for each element of the trajectory. No defaults.</td>
    </tr>
    <tr>
        <td>M1Move ... M8Move</td>
        <td>bo</td>
        <td>Flag defining whether each motor is to be moved
        during the trajectory. 0=No, 1=Yes. Default=0.</td>
    </tr>
    <tr>
        <td>NPulses</td>
        <td>longout</td>
        <td>Number of synchronization pulses to be output by the
        MM4005. Default=200.</td>
    </tr>
    <tr>
        <td>StartPulses</td>
        <td>longout</td>
        <td>The trajectory element number where synchronization
        pulses should start. Default=1.</td>
    </tr>
    <tr>
        <td>EndPulses</td>
        <td>longout</td>
        <td>The trajectory element number where synchronization
        pulses should end. Default=NElements. The SNL program
        sets EndPulses=NElements whenever NElements is changes,
        since this is what is normally desired. EndPulses can be
        changed after changing NElements if desired.</td>
    </tr>
    <tr>
        <td>NActual</td>
        <td>longout</td>
        <td>The actual number of pulses output by the MM4005.
        This value is set when a Readback operation is done.</td>
    </tr>
    <tr>
        <td>TimeMode</td>
        <td>bo</td>
        <td>The mode being used to define the time per trajectory
        element. 0=Total means that the total time for the
        trajectory is being defined, and the TimeTraj array will
        be computed by setting the execution time for each
        element = Time/NElements. 1=Per Element means that the
        time per element has already been loaded into the
        TimeTraj array. This mode permits each element to have a
        different execution time. Default = 0.</td>
    </tr>
    <tr>
        <td>Time</td>
        <td>ao</td>
        <td>Total trajectory execution time. Used when
        TimeMode=0. Default=10.</td>
    </tr>
    <tr>
        <td>TimeTraj</td>
        <td>waveform, double</td>
        <td>The array containing the execution time per
        trajectory element. This array is computed by the SNL
        program if TimeMode=0, and must be loaded by the user if
        TimeMode=1.</td>
    </tr>
    <tr>
        <td>Accel</td>
        <td>ao</td>
        <td>The acceleration time for the trajectory. Default=0.5
        seconds.</td>
    </tr>
    <tr>
        <td>M1Name ... M8Name</td>
        <td>stringout</td>
        <td>The name of each motor. These are used for the MEDM
        screens and for use for channel access clients. These
        names are defined when the database is loaded. These PVs
        are not otherwise used and are not required for the
        trajectory definition.</td>
    </tr>
</table>

<p>The EPICS interface permits the motor positions for each
element of the trajectory to be defined in one of 3 ways. This
flexibility can remove the burden of converting absolute
positions to displacements from the EPICS channel access client
(e.g. SPEC) and let the SNL program to the calculations. MoveMode
can have the following 3 values:</p>

<ul>
    <li><font face="Times New Roman"><code>Relative</code></font>.
        This mode maps directly to the way the MM4005 works
        internally. Each trajectory element is a displacement or
        distance for the motor to move during that element.</li>
    <li><font face="Times New Roman"><code>Absolute</code></font>.
        In this mode each trajectory element is an absolute motor
        position which the controller will move to at each point
        in the trajectory. In practice the SNL program computes
        an internal trajectory with <font face="Times New Roman"><code>N-1</code></font>
        elements where <font face="Times New Roman"><code>InternalTraj[i]
        = MnTraj[i+1]-MnTraj[i]</code></font>. The SNL program
        drives all the motors to the first point in the
        trajectory, waits for them to get there, and then
        executes the new trajectory. The disadvantage of <font
        face="Times New Roman"><code>absolute</code></font> mode
        is that a new trajectory needs to be downloaded and built
        each time the absolute position of any motor in the
        trajectory is changed.</li>
    <li><font face="Times New Roman"><code>Hybrid</code></font>.
        In this mode the trajectory is defined in absolute
        coordinates, as in absolute mode. Again, an internal
        trajectory is computed from <font face="Times New Roman"><code>MnTraj[i+1]-MnTraj[i]</code></font>.
        However, when the trajectory is executed the motors are <strong>not</strong>
        moved to the position of the first point of the
        trajectory. Thus, <font face="Times New Roman"><code>Hybrid</code></font>
        mode permits a trajectory to be defined in absolute
        coordinates, but executed as motions relative to the
        current positions of the motors when the trajectory is
        executed. Thus the motors can be moved using the EPICS
        motor record, and the trajectory executed at a new
        absolute position without downloading new values to
        MnTraj or rebuilding the trajectory.</li>
</ul>

<p>The MM4005 requires the number of elements in a trajectory to
be a multiple of 4. This means that <font face="Times New Roman"><code>NElements</code></font>
should be a multiple of 4 in <font face="Times New Roman"><code>Relative</code></font>
mode and a multiple of 4 plus 1 in <font face="Times New Roman"><code>Absolute</code></font>
or <font face="Times New Roman"><code>Hybrid</code></font> mode.
However, this can be an inconvenience for EPICS channel access
clients. The SNL program works around this restriction as
follows. If <font face="Times New Roman"><code>NElements</code></font>
is not a multiple of 4 for <font face="Times New Roman"><code>MoveMode=Relative
</code></font>or a multiple of 4 plus 1 for <font
face="Times New Roman"><code>MoveMode=Absolute</code></font> or <font
face="Times New Roman"><code>Hybrid</code></font>, then up to 3
padding elements are automatically added to the user defined
trajectory to satisfy the requirment. The padding elements always
have a time of 0.1 seconds. The displacements of the motors in
these padding elements is computed to maintain the same velocity
as the last element in the original trajectory. Thus the padding
elements will cause the trajectory to execute for up to 0.3
seconds longer than requested, and the motors will move slightly
farther than requested. However, there will be no velocity
change, and hence no unexpected accelerations during the padding
elements.</p>

<p>The number of trajectory elements, NElements is limited as
follows.</p>

<ul>
    <li>The MM4005 allows a maximum of 2000 trajectory elements.</li>
    <li>Channel access is also limited to 2000 points, since it
        has a 16,000 byte limit, and all arrays are double
        precision, requiring 8 bytes per element.</li>
    <li>There are 9 double precision arrays which are dimensioned
        MAX_ELEMENTS in the SNL program, and 9 waveform records
        (MnTraj and TimeTraj) which are dimensioned NELM in the
        database. If 2000 points are allowed then the total
        memory used in the IOC is 2000*9*8*2 = 288,000 bytes.
        This is a significant amount of memory for an IOC.
        MAX_ELEMENTS is thus presently defined to be 1000 in the
        SNL program. This value can be increased (up to 2000) or
        decreased and the SNL program recompiled. The value of
        NELM can be set to any value up to MAX_ELEMENTS when the
        database is loaded.</li>
</ul>

<p>The number of output pulses, NPulses is limited as follows.</p>

<ul>
    <li>The MM4005 allows a maximum of 2000 output pulses.</li>
    <li>Channel access is also limited to 2000 points, since it
        has a 16,000 byte limit, and some arrays are double
        precision, requiring 8 bytes per element.</li>
    <li>There are 16 double precision arrays which are
        dimensioned MAX_PULSES in the SNL program, and 16
        waveform records (MnActual and MnError) which are
        dimensioned NPULSE in the database. If 2000 points are
        allowed then the total memory used in the IOC is
        2000*16*8*2 = 512,000 bytes. This is a significant amount
        of memory for an IOC. MAX_PULSES is thus presently
        defined to be 1000 in the SNL program. This value can be
        increased (up to 2000) or decreased and the SNL program
        recompiled. The value of NPULSE <strong>must</strong> be
        set to exactly the value of MAX_PULSES when the database
        is loaded.</li>
</ul>

<p>&nbsp;</p>

<h2><a name="Building a Trajectory">Building a Trajectory</a></h2>

<p>After a trajectory has been defined by setting the values of
the PVs described in the previous section it must be built before
it can be executed. Building the trajectory consists of
downloading it to the MM4005 and checking it for errors such as
excess velocities or accelerations.</p>

<p>The following table describes the EPICS PVs used for building
a trajectory.</p>

<table border="1">
    <tr>
        <td><strong>PV Name</strong></td>
        <td><strong>Record Type</strong></td>
        <td><strong>Description</strong></td>
    </tr>
    <tr>
        <td>Build</td>
        <td>busy</td>
        <td>Setting this PV to 1 will build the trajectory,
        downloading it to the MM4005. It will be set back to 0
        automatically when the build is complete.</td>
    </tr>
    <tr>
        <td>BuildState</td>
        <td>mbbi</td>
        <td>The trajectory build state. 0=Done, 1=Busy.</td>
    </tr>
    <tr>
        <td>BuildStatus</td>
        <td>mbbi</td>
        <td>The trajectory build status. 0=Undefined, 1=Success,
        2=Failure.</td>
    </tr>
    <tr>
        <td>BuildMessage</td>
        <td>stringout</td>
        <td>Progress messages while the build is in progress and
        error message if BuildStatus=Failure.</td>
    </tr>
    <tr>
        <td>M1MDVS ... M8MDVS</td>
        <td>ao</td>
        <td>The maximum change in velocity allowed between
        trajectory elements. This value can be set. These values
        are read from the MM4005 when the SNL program starts, so
        the current values can be seen. The acronym is Maximum
        Delta Velocity Set.</td>
    </tr>
    <tr>
        <td>M1MDVA ... M8MDVA</td>
        <td>ao</td>
        <td>The actual maximum change in velocity between
        trajectory elements. This value is read from the MM4005
        after the trajectory is built. MnMDVE gives the specific
        trajectory element in which this maximum change in
        velocity occured. If MnMDVA is greater than MnMDVS then
        the trajectory build will fail. The acronym is Maximum
        Delta Velocity Actual. Read-Only.</td>
    </tr>
    <tr>
        <td>M1MDVE ... M8MDVE</td>
        <td>longout</td>
        <td>The trajectory element number where MnMDVA occurs.
        The acronym is Maximum Delta Velocity Element. Read-Only.</td>
    </tr>
    <tr>
        <td>M1MVA ... M8MVA</td>
        <td>ao</td>
        <td>The actual maximum velocity. This value is read from
        the MM4005 after the trajectory is built. MnMVE gives the
        specific trajectory element in which this maximum
        velocity occured. If MnMVA is greater than the maximum
        velocity allowed for this motor then the build will fail.
        The acronym is Maximum Velocity Actual. Read-Only.</td>
    </tr>
    <tr>
        <td>M1MVE ... M8MVE</td>
        <td>longout</td>
        <td>The trajectory element number where MnMVA occurs. The
        acronym is Maximum Velocity Element. Read-Only.</td>
    </tr>
    <tr>
        <td>M1MAA ... M8MAA</td>
        <td>ao</td>
        <td>The actual maximum acceleration. This value is read
        from the MM4005 after the trajectory is built. MnMAE
        gives the specific trajectory element in which this
        maximum acceleration occured. If MnMVA is greater than
        the maximum acceleration allowed for this motor then the
        build will fail. The acronym is Maximum Acceleration
        Actual. Read-Only.</td>
    </tr>
    <tr>
        <td>M1MAE ... M8MAE</td>
        <td>longout</td>
        <td>The trajectory element number where MnMAA occurs. The
        acronym is Maximum Acceleration Element. Read-Only.</td>
    </tr>
</table>

<p>Channel access clients should do the following to build a
trajectory:</p>

<ul>
    <li>Set Build=1</li>
    <li>Repeatedly read BuildState, wait for it to go to 0=Done.</li>
    <li>When BuildState=Done check BuildStatus. If it is not
        1=Sucess, then something went wrong.</li>
    <li>BuildMessage can be used to determine what the error was,
        although this will probably require a human rather than a
        program.</li>
</ul>

<p>If the build fails then it is useful to look at the
trajectoryScanDebug MEDM screen to examine the maximum velocity
and acceleration values. See if one or more motors is being
commanded to move too fast.</p>

<p>&nbsp;</p>

<h2><a name="Executing a Trajectory">Executing a Trajectory</a></h2>

<p>After a trajectory has been successfully built it can be
executed. The trajectory execution consists of the following
steps:</p>

<ul>
    <li>Remember the initial positions of all the motors.</li>
    <li>Move to the start position defined by MnTraj[0]. This is
        only done if MoveMode=Absolute.</li>
    <li>Trigger the detector start PV.</li>
    <li>Execute the trajectory in either Real or Simulation mode,
        with the execution time scaled by TimeScale. Poll during
        execution and post channel access monitors for the
        current element being executed, for the current positions
        of the motors and for any errors.</li>
    <li>When the trajectory is complete:<ul>
            <li>Trigger the detector stop PV.</li>
            <li>Move the motors back to their initial positions.</li>
        </ul>
    </li>
</ul>

<p>The following table describes the EPICS PVs used for executing
a trajectory.</p>

<table border="1">
    <tr>
        <td><strong>PV Name</strong></td>
        <td><strong>Record Type</strong></td>
        <td><strong>Description</strong></td>
    </tr>
    <tr>
        <td>Execute</td>
        <td>busy</td>
        <td>Setting this PV to 1 will execute the trajectory,
        performing the steps described above. It will be set back
        to 0 automatically when the execution is complete.</td>
    </tr>
    <tr>
        <td>ExecState</td>
        <td>mbbi</td>
        <td>The trajectory execution state. 0=Done, 1=Move Start,
        2=Executing, 3=Flyback.</td>
    </tr>
    <tr>
        <td>ExecStatus</td>
        <td>mbbi</td>
        <td>The trajectory execute status. 0=Undefined,
        1=Success, 2=Failure, 3=Abort, 4=Timeout.</td>
    </tr>
    <tr>
        <td>ExecMessage</td>
        <td>stringout</td>
        <td>Progress messages while the execution is in progress
        and error message if ExecStatus is not Success.</td>
    </tr>
    <tr>
        <td>SimMode</td>
        <td>bo</td>
        <td>Simulation mode. 0=Real, 1=Simulate. The MM4005 can
        execute a trajectory in simulation mode, not actually
        moving any motors. Default=Real.</td>
    </tr>
    <tr>
        <td>TimeScale</td>
        <td>ao</td>
        <td>Scaling time for the trajectory execution. Although a
        trajectory is defined with a particular time per element,
        the execution time can be scaled from this value.
        TimeScale can range from .01 (100 times faster) to 100
        (100 times slower). Default=1.0</td>
    </tr>
    <tr>
        <td>Abort</td>
        <td>bo</td>
        <td>Setting Abort=1 will immediately abort any motion on
        the MM4005. It sends the AB command to the MM4005 which
        turns off the motor power to all motors. To recover from
        this it is usually necessary to rehome the motors, and to
        rebuild the trajectory at least twice before it will
        succeed. Abort is set back to 0 automatically.</td>
    </tr>
    <tr>
        <td>M1Current ... M8Current</td>
        <td>&nbsp;</td>
        <td>The current position of each motor. These values are
        updated and posted during execution of the trajectory.
        They are <strong>not</strong> continuously updated when
        the trajectory is not executing because that could
        interfere with EPICS motor records. This conflict will be
        eliminated in a future release of the MM4005 support for
        the EPICS motor record.</td>
    </tr>
    <tr>
        <td>DetOn</td>
        <td>ao</td>
        <td>The .VAL field of this PV is written to its .OUT
        field in order to turn on the detector just before the
        trajectory is executed. The .VAL and .OUT fields are
        defined when the database is loaded. This mechanism is a
        very flexible way to turn on any sort of detector or set
        of detectors, since any value can be written to any PV.</td>
    </tr>
    <tr>
        <td>DetOff</td>
        <td>ao</td>
        <td>The .VAL field of this PV is written to its .OUT
        field in order to turn off the detector just after the
        trajectory is executed. The .VAL and .OUT fields are
        defined when the database is loaded. This mechanism is a
        very flexible way to turn off any sort of detector or set
        of detectors, since any value can be written to any PV.</td>
    </tr>
</table>

<p>Channel access clients should do the following to execute a
trajectory:</p>

<ul>
    <li>Set Execute=1</li>
    <li>Repeatedly read ExecState, wait for it to go to 0=Done.</li>
    <li>When ExecState=Done check ExecStatus. If it is not
        1=Sucess, then something went wrong.</li>
    <li>ExecMessage can be used to determine what the error was,
        although this will probably require a human rather than a
        program.</li>
</ul>

<p>The execution can fail because the velocity or acceleration is
too large, even if the build succeeded, if TimeScale is greater
than 1.0.</p>

<p>&nbsp;</p>

<h2><a name="Reading Back a Trajectory">Reading Back a Trajectory</a></h2>

<p>After a trajectory has been executed it is possible to read
back from the MM4005 the theoretical and actual positions of the
motors when each synchronization pulse was output. The EPICS
interface presents this information as the actual positions and
the following errors (actual position minus theoretical position)
since these are usually of most interest to the user. Obviously
the theoretical position can be computed from the actual position
and the following error.</p>

<p>Reading back this information is rather slow, but in many
cases does not need to be done for each scan. Once it is
established that the following errors are small enough it is
possible to execute scans without reading back from the MM4005
each time. The time is determined by the speed of the
communications interface to the MM4005. Each point returned from
the MM4005 is about 200 characters. Using MPF or Hideos at 19,200
baud on a serial link this requires 0.1 seconds per point, where
the number of points is equal to the number of output pulses.
This is thus 30 seconds for a scan with 300 output pulses.</p>

<p>The following table describes the EPICS PVs used for reading
back a trajectory.</p>

<table border="1">
    <tr>
        <td><strong>PV Name</strong></td>
        <td><strong>Record Type</strong></td>
        <td><strong>Description</strong></td>
    </tr>
    <tr>
        <td>Readback</td>
        <td>busy</td>
        <td>Setting this PV to 1 will read back the results of
        the trajectory motion from the MM4005. It will be set
        back to 0 automatically when the readback is complete.</td>
    </tr>
    <tr>
        <td>ReadState</td>
        <td>mbbi</td>
        <td>The readback state. 0=Done, 1=Busy.</td>
    </tr>
    <tr>
        <td>ReadStatus</td>
        <td>mbbi</td>
        <td>The readback status. 0=Undefined, 1=Success,
        2=Failure.</td>
    </tr>
    <tr>
        <td>ReadMessage</td>
        <td>stringout</td>
        <td>Progress messages while the readback is in progress
        and error message if ReadStatus is not Success.</td>
    </tr>
    <tr>
        <td>M1Actual ... M8Actual</td>
        <td>waveform, double</td>
        <td>The actual position of the motor when each pulse was
        output by the MM4005 during the trajectory scan.</td>
    </tr>
    <tr>
        <td>M1Error ... M8Error</td>
        <td>waveform, double</td>
        <td>The following error of the motor when each pulse was
        output by the MM4005 during the trajectory scan. The
        following error is defined as actual position minus
        theoretical position. </td>
    </tr>
</table>

<p>Channel access clients should do the following to read back a
trajectory:</p>

<ul>
    <li>Set Readback=1</li>
    <li>Repeatedly read ReadState, wait for it to go to 0=Done.</li>
    <li>When ReadState=Done check ReadStatus. If it is not
        1=Sucess, then something went wrong.</li>
    <li>ReadMessage can be used to determine what the error was,
        although this will probably require a human rather than a
        program.</li>
</ul>

<p>Note that the readback command reads the global trace buffer
of the MM4005. It can be used to read back this trace buffer even
if the previous operation was not a trajectory execution. This
can be useful for debugging operation of the diffractometer in
general.</p>

<p>&nbsp;</p>

<h2><a name="Interaction with EPICS Motor Records">Interaction
with EPICS Motor Records</a></h2>

<p>The trajectory scanning does not use the EPICS motor records,
but rather talks directly to the MM4005 controller. In order to
keep the motor records in sync with reality the SNL program
always returns the motors to their original positions, i.e. the
positions where the motor records think they are, after a
trajectory execution is complete. One should not move any motors
on an MM4005 while a trajectory scan is in progress.</p>

<p>When a motion is aborted with the Abort PV it will be
necessary to home the motors and synchronize the motor records
with the actual positions of the motors.</p>

<p>&nbsp;</p>

<h2><a name="Communication with the MM4005">Communication with
the MM4005</a></h2>

<p>The standard database, trajectoryScan.db, uses two Generic
Serial Records to communicate with the MM4005. One of these
serial records is used for output only (StringOut) and the other
is used for sending a command and reading a response
(StringOutIn). Having two records rather than one eliminates the
need to frequently change the .TMOD field between Write and
Write/Read. </p>

<p>It should be possible to replace the Generic Serial Records
with Generic GPIB Records if one is using GPIB rather than RS-232
to communicate with the MM4005. There should be no changes
required to the SNL program, since the field names are identical
for the two records. However, this has not yet been tested.</p>

<p>The timeout field (.TMOT) of the StringOutIn record is set to
5000 msec in the database. This was found to be necessary to
allow for the long time it takes the MM4005 to respond to the TB
command after a VC command is issued when verifying the
trajectory. However, it would probably be better to determine
empirically how long it takes the MM4005 to verify trajectories
as a function of NElements and NPulses and have the SNL program
wait that long after sending the VC command and before sending
the TB command. These measurements have not been done yet.</p>

<p>Note that string fields in EPICS records are limited to 40
characters. The responses from the MM4005 can be longer than 40
characters, so the StringOutIn record uses .IFMT=Binary, reading
into a char buffer rather than a string field. This is mildly
inconvenient since it is not possible to display this field in an
MEDM screen for debugging. However, there is another record with
a string field, MMResponse. The SNL program copies the first 40
characters of every response from the MM4005 from StringOutIn to
MMResponse. This record can be displayed in MEDM.</p>

<p>The following table describes the EPICS PVs used for
communicating with the MM4005.</p>

<table border="1">
    <tr>
        <td><strong>PV Name</strong></td>
        <td><strong>Record Type</strong></td>
        <td><strong>Description</strong></td>
    </tr>
    <tr>
        <td>StringOut</td>
        <td>serial</td>
        <td>Used to send commands to the MM4005.</td>
    </tr>
    <tr>
        <td>StringOutIn</td>
        <td>serial</td>
        <td>Used to send commands and read responses from the
        MM4005.</td>
    </tr>
    <tr>
        <td>MMResponse</td>
        <td>stringout</td>
        <td>Used to display the first 40 characters of the
        response from the MM4005 for debugging.</td>
    </tr>
</table>

<p>&nbsp;</p>

<h2><a name="Hardware Notes">Hardware Notes</a></h2>

<p>The synchronization output pulses from the MM4005 are provided
on pin 12 of the DB-25 Auxilliary Connector. We have found it
convenient to make a connector with a short BNC pigtail coming
from this pin. This pulse output from the MM4005 is an
open-collector circuit. The maximum rating is 30V and 40 mA. </p>

<p>When using the pulse output as the channel-advance input of
the Struck 7201 or SIS 380x multi-scaler some modifications are
required. The SIS 380x manual states that with the LEMO TTL input
configuration the inputs are pulled up to +5V with 1K Ohm
resistors in a resistor pack. For our module the factory
configuration was actually a 4.7K Ohm resistor pack. These
resistors did pull the open-collector output up to +5V. However,
when driving the cable over a long distance (~80 feet) the rise
time of the signal was quite slow, about 8 microseconds to go
from 0V to the TTL threshold. This slow rise time caused the SIS
380x to double count the channel advance signal most of the time.
By replacing the 4.7K Ohm resistor pack with a 200 Ohm pull-up
resistor pack the rise time was reduced to about 2 microseconds,
and the module does not double count. 200 Ohms is within the spec
of the MM4005, since it will result in a current of 5V/200 Ohm =
25 mA, which is less than the 40 mA maximum.</p>

<p>&nbsp;</p>

<h2><a name="vxWorks startup file">vxWorks startup file</a></h2>

<p>The following are the comments from the beginning of
trajectoryScan.db which describe the macro parameters which must
be supplied in the dbLoadRecords command in the vxWorks startup
script.</p>

<pre>
# Database for Newport MM4005 trajectory scanning.
# 
# Mark Rivers
# August 12, 2000
#
# Note: This database is completely general for the MM4005, it makes no
# assumptions about the motors defined on particular axis. Thus it can be used
# with the Newport diffractometer or any other set of up to 8 motors.
#
# Macro paramters:
# $(P)      - PV name prefix
# $(R)      - PV base record name
# $(NAXES)  - Number of axes to be used. Typically 6 for diffractometer.
# $(NELM)   - Maximum number of trajectory elements
# $(NPULSE) - Maximum number of output pulses
# $(DONPV)  - Name of PV to turn detector on
# $(DONV)   - Value to write to DONPV to turn detector on
# $(DOFFPV) - Name of PV to turn detector off
# $(DOFFV)  - Value to write to DOFFPV to turn detector off
# $(C)      - Card # (0,1,2...) of the board with the IP slot for the
#             generic serial records
# $(IPSLOT) - IP slot (A-D) for the serial I/O module
# $(CHAN)   - Channel (0-7) for the serial port
# $(BAUD)   - Baud rate for the serial port
#             Note: the MM4005 is assumed to be configured with 8 data bits,
#             1 stop bit, no parity.
</pre>

<p>The following is an example vxWorks startup file which loads
trajectoryScan.db. Note that the command line is longer than the
vxWorks limit, so the command must be built using malloc, strcpy
and strcat.</p>

<pre>
# Database for trajectory scanning with the MM4005/GPD
# The required command string is longer than the vxWorks
# command line, must use malloc and strcpy, strcat
str = malloc(300)
strcpy(str,&quot;P=13IDC:,R=traj1,NAXES=6,NELM=1000,NPULSE=1000,C=0,IPSLOT=a,CHAN=2,BAUD=19200&quot;)
strcat(str,&quot;,DONPV=13IDC:str:EraseStart,DONV=1,DOFFPV=13IDC:str:StopAll,DOFFV=1&quot;)
strcat(str,&quot;,M1=Phi,M2=Kappa,M3=Omega,M4=Psi,M5=2-Theta,M6=Nu,M7=Unused,M8=Unused&quot;)
dbLoadRecords(&quot;CARSApp/Db/trajectoryScan.db&quot;, str)
</pre>

<p>DONPV and DOFFPV in this example are for the Struck/SIS
multichannel scaler database (Struck8.db). For this database
writing a 1 to EraseStart clears and starts the multichannel
scaler, writing 1 to StopAll stops it. The names M1 ... M8 are
used to load the MnName records, which in turn provide the motor
labels on the MEDM displays.</p>

<p>After iocInit is called in the startup script the SNL program
must be started. Here is an example:</p>

<pre>seq &amp;trajectoryScan, &quot;P=13IDC:, R=traj1&quot; </pre>

<p>&nbsp;</p>

<h2><a name="MEDM screens">MEDM screens</a></h2>

<p>The following show the MEDM screens with which the user can
view and modify the trajectory scanning parameters.</p>

<p>trajectoryScan.adl is the main screen used to define, build,
execute and read back trajectories. The only thing which cannot
be done in MEDM is to edit the MnTraj and TimeTraj arrays, since
MEDM does not provide a method to edit arrays. trajectoryScan.adl
is called with macro parameters P, R, and M1 ... M8. P and R are
the prefix and record base used when the database was loaded. M1
... M8 are the names of the motors. These are used to label the
plots in trajectoryPlot.adl. For example trajectoryScan.adl in
this screen shot was called with P=13IDC:, R=traj1, M1=Phi,
M2=Kappa, M3=Omega, M4=Psi, M5=2-Theta, M6=Nu, M7=Unused,
M8=Unused.</p>

<p><img src="trajectoryScan.gif" width="538" height="782"></p>

<p>trajectoryPlot.adl is used to plot the requested trajectory in
position and time (MnTraj, TimeTraj), the readback positions
(MnActual) and the following errors (MnError).</p>

<p><img src="trajectoryPlot1.gif" width="408" height="227"><img
src="trajectoryPlot2.gif" width="408" height="227"></p>

<p>trajectoryScanDebug is used to display detailed information,
useful for debugging.</p>

<p><img src="trajectoryScanDebug.gif" width="1023" height="447"></p>

<p>&nbsp;</p>

<h2><a name="Example IDL Procedure">Example IDL Procedure</a></h2>

<p>The following IDL fucntion illustrates how an EPICS channel
access client can define, build, execute and read back
trajectory.</p>

<pre>
function trajectory_demo1, build=build, execute=execute, read=read, $
                          actual, error, counts

;+
; NAME:
;       trajectory_demo1
;
; PURPOSE:
;       This IDL function demonstates how a channel access client can 
;       define, build, execute and read back a complex trajectory with the 
;       MM4005.
;
;       The trajectory parameters are as follows:
;       101 elements, 300 output pulses, 30 second execution time, 1 second
;       acceleration time.
;
;       Only the Phi and Kappa axes are moved.
;
;       The Phi trajectory is a sin wave with two complete periods and an
;       amplitude of +-8 degrees.
;
;       The Kappa trajectory is a sin wave with one complete period and an
;       amplitude of +-20 degrees.
;
;       The readback includes the Phi, Kappa and Omega actual positions and
;       following errors. Omega is interesting because although it was not
;       moved during the trajectory it has some following error because of 
;       the moving mass of the Kappa arm.
;
;       The function returns counts from an SIS multichannel scaler which is
;       triggered by the output pulses.
;
; CATEGORY:
;       EPICS trajectory scanning
;
; CALLING SEQUENCE:
;       Result = TRAJECTORY_DEMO1(Actual, Error, Counts)
;
; INPUTS:
;       None.
;
; KEYWORD PARAMETERS:
;       BUILD:      Set this keyword to build the trajecotry
;
;       EXECUTE:    Set this keyword to execute the trajectory
;
;       READ:       Set this keyword to read back the trajectory into
;                   Actual and Error
;
;       NOTE: Any or all of these keywords can be set.  If none is set then the
;             function does not do anything.
;
; OUTPUTS:
;       Result:     This function returns a status indicating whether the
;                   selected opetations were successful or not. 0=success,
;                   anything else is a failure.
;       Actual:     An array of [Nactual, 3] containing the actual positions of
;                   the Phi, Kappa and Omega axes.
;       Error:      An array of [Nactual, 3] containing the following errors of
;                   the Phi, Kappa and Omega axes.
;       Counts:     An array of [Nactual, 4] containing the counts from the
;                   SIS 3801 multi-channel scaler. The EPICS_MED class library
;                   is used to communicate with this device.
;
;       NOTE: The Actual, Error and Counts outputs are only returned if the 
;             READ keyword it set.
;
; SIDE EFFECTS:
;       This procedure can move the diffractometer.  Be careful!
;
; EXAMPLE:
;       status = trajectory_demo1(/build)
;       status = trajectory_demo1(/execute)
;       status = trajectory_demo1(/read, actual, error, counts)
;       plot, actual[*,0]
;       plot, error[*,0]
;       plot, counts[*,0]
;
; MODIFICATION HISTORY:
;       Written by:     Mark Rivers, August 13, 2000
;-

    prefix  = '13IDC:'
    traj    = prefix + 'traj1'
    phi     = traj + 'M1'
    kappa   = traj+'M2'
    omega   = traj+'M3'
    mcs     = prefix + 'str:'

    ; Make sure the MCS is in External channel advance mode
    t = caput(mcs+'ChannelAdvance', 'External')

    if (keyword_set(build)) then begin

        ; The trajectory definition is hybid mode, meaning the positions are
        ; definined in absolute coordinates rather than displacements from on
        ; element to the next. However, the motors do not move to the absolute
        ; position of the first element before executing the trajectory.
        MoveMode = 'Hybrid'
        t = caput(traj+'MoveMode', MoveMode)

        ; 101 elements in the trajectory. We use 4N+1 since we are defining the
        ; trajectory in Hybrid mode
        nelements = 101
        t = caput(traj+'Nelements', nelements)

        ; 300 output pulses during the trajectory
        npulses = 300
        t = caput(traj+'Npulses', npulses)

        ; 30 seconds total time to execute the trajectory
        t = caput(traj+'TimeMode', 'Total')
        time = 30.
        t = caput(traj+'Time', time)

        ; 1 second acceleration time
        accel = 1.
        t = caput(traj+'Accel', accel)

        ; The Phi and Kappa motors will move.
        t = caput(phi+'Move', 1)
        t = caput(kappa+'Move', 1)

        ; The Phi trajectory is a sin wave with two complete periods and an
        ; amplitude of +-8 degrees
        phiTraj = 8.*sin(findgen(nelements)/(nelements-1.)*4.*!pi)
        t = caput(phi+'Traj', phiTraj)

        ; The Kappa trajectory is a sin wave with one complete period and an
        ; amplitude of +-20 degrees
        kappaTraj = 20.*sin(findgen(nelements)/(nelements-1.)*2.*!pi)
        t = caput(kappa+'Traj', kappaTraj)

        ; Trajectory is now defined.  Build it.
        t = caput(traj+'Build', 1)
        ; Wait for the build to complete. Wait 1 second between polls. The
        ; first wait is important to allow the build to begin.
        repeat begin
            wait, 1.
            t = caget(traj+'BuildState', BuildState)
        endrep until (BuildState eq 0)

        ; Make sure the build was successful
        t = caget(traj+'BuildStatus', BuildStatus, /string)
        if (BuildStatus ne 'Success') then begin
            t = caget(traj+'BuildMessage', BuildMessage)
            print, 'Build failed, error = ', BuildMessage
            return, BuildStatus
        endif
    endif

    if (keyword_set(execute)) then begin
        t = caput(traj+'Execute', 1)
        ; Wait for the execute to complete. Wait 1 second between polls. The
        ; first wait is important to allow the execution to begin.
        repeat begin
            wait, 1.
            t = caget(traj+'ExecState', ExecState)
        endrep until (ExecState eq 0)

        ; Make sure the execution was successful
        t = caget(traj+'ExecStatus', ExecStatus, /string)
        if (ExecStatus ne 'Success') then begin
            t = caget(traj+'ExecMessage', ExecMessage)
            print, 'Execution failed, error = ', ExecMessage
            return, ExecStatus
        endif
    endif

    if (keyword_set(read)) then begin
        t = caput(traj+'Readback', 1)
        ; Wait for the readback to complete. Wait 1 second between polls. The
        ; first wait is important to allow the readback to begin.
        repeat begin
            wait, 1.
            t = caget(traj+'ReadState', ReadState)
        endrep until (ReadState eq 0)

        ; Make sure the readback was successful
        t = caget(traj+'ReadStatus', ReadStatus, /string)
        if (ReadStatus ne 'Success') then begin
            t = caget(traj+'ReadMessage', ReadMessage)
            print, 'Read failed, error = ', ReadMessage
            return, ReadStatus
        endif

        ; Read the Phi and Kappa actual and error arrays into IDL, return to
        ; caller
        t = caget(traj+'Nactual', nactual)
        t = caget(Phi+'Actual', PhiActual, max=nactual)
        t = caget(Phi+'Error',  PhiError,  max=nactual)
        t = caget(Kappa+'Actual', KappaActual, max=nactual)
        t = caget(Kappa+'Error',  KappaError,  max=nactual)
        t = caget(Omega+'Actual', OmegaActual, max=nactual)
        t = caget(Omega+'Error',  OmegaError,  max=nactual)
        actual = [[PhiActual], [KappaActual], [OmegaActual]]
        error  = [[PhiError],  [KappaError],  [OmegaError]]

        ; Read the counts from the SIS multichannel scaler
        med = obj_new('EPICS_MED', mcs, 4)
        counts = med-&gt;get_data()
        counts = counts[0:nactual-1,*]
    endif

    return, 0
end
</pre>
</body>
</html>
