#
#  @(#)scans.mac	4.7  09/17/99 CSS
#
#  "Spec" Release 4
#
#  Copyright (c) 1988,1989,1990,1991,1992,1993,1997,1998,1999
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################

#########################################################################
#
#                        BASIC SCANS
#
#########################################################################
#
# `ascan' is a single-motor scan
#
def ascan '
	if ($# != 5) {
		eprint "Usage:  ascan  motor start finish  intervals time"
		exit
	} 
	_check0 "$1"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_n1 = int($4); _ctime = $5
	_nm = 1
	_ascan
'
#########################################################################
#
# `a2scan' is a two-motor scan
#
def a2scan '
	if ($# != 8) {
		eprint "\
Usage:  a2scan  motor1 s1 f1  motor2 s2 f2  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_n1 = int($7); _ctime = $8
	_nm = 2
	_ascan
'
#########################################################################
#
# `a3scan' is a three-motor scan
#
def a3scan '
	if ($# != 11) {
		eprint "\
Usage:  a3scan  motor1 s1 f1  motor2 s2 f2  motor3 s3 f3  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_n1 = int($10); _ctime = $11
	_nm = 3
	_ascan
'
#########################################################################
#
# `a4scan' is a four-motor scan
#
def a4scan '
	if ($# != 14) {
		eprint "\
Usage:  a4scan  m1 s1 f1  m2 s2 f2  m3 s3 f3  m4 s4 f4  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"; _check0 "$10"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_m[3] = $10; _s[3] = $11; _f[3] = $12
	_n1 = int($13); _ctime = $14
	_nm = 4
	_ascan
'
#########################################################################
#
# `a5scan' is a five-motor scan
#
def a5scan '
	if ($# != 17) {
		eprint "\
Usage:  a5scan  m1 s1 f1 m2 s2 f2 m3 s3 f3 m4 s4 f4 m5 s5 f5  intervals time"
		exit
	} 
	_check0 "$1"; _check0 "$4"; _check0 "$7"; _check0 "$10"; _check0 "$13"
	_m[0] = $1; _s[0] = $2; _f[0] = $3
	_m[1] = $4; _s[1] = $5; _f[1] = $6
	_m[2] = $7; _s[2] = $8; _f[2] = $9
	_m[3] = $10; _s[3] = $11; _f[3] = $12
	_m[4] = $13; _s[4] = $14; _f[4] = $15
	_n1 = int($16); _ctime = $17
	_nm = 5
	_ascan
'
#########################################################################
#
# `mesh' is a two-motor nested scan
#
def mesh '
	if ($# != 9) {
		eprint "\
Usage:  mesh  mot1 s1 f1 intervals1  mot2 s2 f2 intervals2  time"
		exit
	} 
	_check0 "$1"; _check0 "$5"
	{
		_m[0] = $1; _s1 = $2; _f1 = $3; _n1 = int($4)
		_m[1] = $5; _s2 = $6; _f2 = $7; _n2 = int($8)
		_ctime = $9
	}
	if (_n1 <= 0 || _n2 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	_bad_lim = 0
	_chk_lim _m[0] _s1
	_chk_lim _m[0] _f1
	_chk_lim _m[1] _s2
	_chk_lim _m[1] _f2
	if (_bad_lim) exit

	HEADING = sprintf("mesh  $1 %g %g %g  $5 %g %g %g  %g",\
			$2, $3, $4, $6, $7, $8, $9)

	_d1 = (_f1 - _s1) / _n1++; _d2 = (_f2 - _s2) / _n2++
	_nm=2
	_cols=2+_hkl_col
	X_L = "$1"; _sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype = 1|8|(2<<8)
	FPRNT=sprintf("%s  %s  ",motor_name(_m[0]),motor_name(_m[1]))
	PPRNT=sprintf("%8.8s %8.8s ",motor_name(_m[0]),motor_name(_m[1]))
	VPRNT=sprintf("%9.9s %9.9s ",motor_name(_m[0]),motor_name(_m[1]))
	FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
	scan_head
	PFMT=sprintf("%%8.%df %%8.%df ",UP,UP)
	VFMT=sprintf("%%9.%df %%9.%df ",UP,UP)
	_g1 = _n1
	_g2 = 0
	def _scan_on \'
	 for (; _g2 < _n2; _g2++){
		A[_m[1]] = _s2 + _g2 * _d2
		if (_g1 == _n1)
			_g1 = 0
		for (; _g1 < _n1; _g1++, NPTS++) {
			A[_m[0]] = _s1 + _g1 * _d1
			scan_move
			FPRNT=sprintf("%.8g %.8g ",A[_m[0]],A[_m[1]])
			PPRNT=sprintf(PFMT,A[_m[0]],A[_m[1]])
			VPRNT=sprintf(VFMT,A[_m[0]],A[_m[1]])
			FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
			scan_loop
			scan_data(_g1,A[_m[0]])
			scan_plot
		}
	 }
	 scan_tail
	\'
	_scan_on
'

#########################################################################
#
# `hklscan' is a general linear reciprocal space scan
# (Limit checking is done at the last point first, since limits
# are often exceeded at the extreme points of a scan.)
def hklscan '
	if ($# != 8) {
		eprint "\
Usage:  hklscan Hstart Hfinish Kstart Kfinish Lstart Lfinish intervals time"
		exit
	} 
	{
		_s1 = $1; _f1 = $2; _s2 = $3; _f2 = $4; _s3 = $5; _f3 = $6
		_n1 = int($7); _ctime = $8
	}

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 
	HEADING = sprintf("hklscan  %g %g  %g %g  %g %g  %g %g", $1,$2,$3,\
		$4,$5,$6,$7,$8)
	_d1 = (_f1 - _s1)/_n1
	_d2 = (_f2 - _s2)/_n1
	_d3 = (_f3 - _s3)/_n1++

	H=_f1; K=_f2; L=_f3
	calcA; _bad_lim=0; _hkl_lim
	if (_bad_lim) {
		eprintf("(H K L = %g %g %g)\n",H,K,L)
		exit
	}
	if (_pre_chk) {
		local i
		for (i=0;i<_n1;i++) {
			H = _s1 + i*_d1
			K = _s2 + i*_d2
			L = _s3 + i*_d3
			calcA
			_bad_lim = 0
			_hkl_lim
			if (_bad_lim) {
				eprintf("(H K L = %g %g %g)\n",H,K,L)
				exit
			}
		}
	}
	_cols=3
	if (_d3)
		{ X_L = "L"; _sx = _s3; _fx = _f3 }
	else if (_d2)
		{ X_L = "K"; _sx = _s2; _fx = _f2 }
	else
		{ X_L = "H"; _sx = _s1; _fx = _f1 }
	Y_L = cnt_name(DET)
	_stype = 2
	FPRNT="H  K  L  "
	PPRNT=""
	{
	 local i
	 for (i=0;i<_numgeo;i++)
		PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(mA[i]))
	}
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")
	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i h_ca k_ca l_ca
		H = h_ca = _s1 + NPTS*_d1
		K = k_ca = _s2 + NPTS*_d2
		L = l_ca = _s3 + NPTS*_d3
		get_angles; calcA
		scan_move
		FPRNT=sprintf("%g %g %g ",h_ca,k_ca,l_ca)
		PPRNT=""
		for (i=0;i<_numgeo;i++)
			PPRNT=sprintf("%s%8.4f ",PPRNT,A[mA[i]])
		VPRNT=sprintf("%10.5g %10.5g %10.5g ",h_ca,k_ca,l_ca)
		scan_loop
		scan_data(NPTS,_d3? l_ca:(_d2? k_ca:h_ca))
		H=h_ca; K=k_ca; L=l_ca
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'
#########################################################################
#
# `hklmesh' is a two-Q nested scan.  It uses the fact that H, K and L
# are defined as Q[0], Q[1] and Q[2], respectively.
#
def hklmesh '
	_m1 = index("HKL", "$1")
	_m2 = index("HKL", "$5")
	if ($# != 9 || !_m1 || !_m2 || _m1 == _m2) {
		eprint "\
Usage:  hklmesh  Q1 s1 f1 intervals1  Q2 s2 f2 intervals2  time\n\
	Q1 and Q2 are H, K or L.  Q1 != Q2"
		exit
	}
	waitall; get_angles; calcHKL
	{
		_m1--; _s1 = $2; _f1 = $3; _n1 = int($4)
		_m2--; _s2 = $6; _f2 = $7; _n2 = int($8)
		_ctime = $9
	}
	if (_n1 <= 0 || _n2 <= 0) {
		eprint "Intervals <= 0"
		exit
	}

	HEADING = sprintf("hklmesh  $1 %g %g %g  $5 %g %g %g  %g",\
			$2,$3,$4,$6,$7,$8,$9)

	_d1 = (_f1 - _s1) / _n1++; _d2 = (_f2 - _s2) / _n2++
	if (_pre_chk) {
		local i j
		for (i=0; i<_n2; i++) {
			Q[_m2] = _s2 + i * _d2
			for (j=0; j<_n1; j++) {
				Q[_m1] = _s1 + j * _d1
				calcA
				_bad_lim = 0
				_hkl_lim
				if (_bad_lim) {
					eprintf("(H K L = %g %g %g)\n", H,K,L)
					exit
				}
				calcHKL
			}
		}
	}
	_cols=3
	X_L = "$1"; _sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype=2|8
	FPRNT="H  K  L  "
	PPRNT=""
	{
	 local i
	 for (i=0;i<_numgeo;i++)
		PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(mA[i]))
	}
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")
	scan_head
	_hklmesh
'
# Long macro definition requires 2 parts
#  save Q[_m3] at start of mesh and restore at each point to prevent drift
def _hklmesh '
	_m3 = 3 - _m1 - _m2
	_g1 = _n1
	_g2 = 0
	def _scan_on \'
	 {
	  local _ca
	  _ca[_m3] = Q[_m3]
	  for (; _g2 < _n2; _g2++){
		Q[_m2] = _ca[_m2] = _s2 + _g2 * _d2
		if (_g1 == _n1)
			_g1 = 0
		for (; _g1 < _n1; _g1++, NPTS++) {
			local i
			Q[_m1] = _ca[_m1] = _s1 + _g1 * _d1
			Q[_m3] = _ca[_m3]
			get_angles; calcA
			scan_move
			FPRNT=sprintf("%g %g %g ", _ca[0],_ca[1],_ca[2])
			PPRNT=""
			for (i=0;i<_numgeo;i++)
				PPRNT=sprintf("%s%8.4f ",PPRNT,A[mA[i]])
			VPRNT=sprintf("%10.5g %10.5g %10.5g ",\
							_ca[0],_ca[1],_ca[2])
			scan_loop
			scan_data(_g1,_ca[_m1])
			scan_plot
		}
	  }
	 }
	 scan_tail
	\'
	_scan_on
'


#########################################################################
#
# `hkcircle', `hlcircle', `klcircle', `hkradial', `hlradial', `klradial'
#  (with `_hklline') do circle and radial cuts in HKL space
#
# Circular scan in the H-K plane
def hkcircle '
	if ($# < 5) {
		eprint "\
Usage:  hkcircle radius angle_start angle_finish intervals time [L=expr]\n\
	(i.e. L=H/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = _const * sin(rad(\$1))
		K = _const * cos(rad(\$1))
	"
	X_L = "Angle"
	HEADING = sprintf("hkcircle %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Circular scan in the H-L plane
def hlcircle '
	if ($# < 5) {
		eprint "\
Usage:  hlcircle radius angle_start angle_finish intervals time [K=expr]\n\
	(i.e. K=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = _const * sin(rad(\$1))
		L = _const * cos(rad(\$1))
	"
	X_L = "Angle"
	HEADING = sprintf("hlcircle %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Circular scan in the K-L plane
def klcircle '
	if ($# < 5) {
		eprint "\
Usage:  klcircle radius angle_start angle_finish intervals time [H=expr]\n\
	(i.e. H=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		K = _const * sin(rad(\$1))
		L = _const * cos(rad(\$1))
	"
	X_L = "Angle"
	HEADING = sprintf("klcircle %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Radial scan in the H-K plane
def hkradial '
	if ($# < 5) {
		eprint "\
Usage:  hkradial angle start finish intervals time [L=expression]\n\
	(i.e.  L=H/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = \$1 * sin(rad(_const))
		K = \$1 * cos(rad(_const))
	"
	X_L = "Radius"
	HEADING = sprintf("hkradial %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Radial scan in the H-L plane
def hlradial'
	if ($# < 5) {
		eprint "\
Usage:  hlradial angle start finish intervals time [K=expression]\n\
	(i.e. K=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		H = \$1 * sin(rad(_const))
		L = \$1 * cos(rad(_const))
	"
	X_L = "Radius"
	HEADING = sprintf("hlradial %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
# Radial scan in the K-L plane
def klradial '
	if ($# < 5) {
		print "\
Usage:  klradial angle start finish intervals time [H=expression]\n\
	(i.e. H=L/300, ...)"
		exit
	} 
	#
	def _hkl "
		K = \$1 * sin(rad(_const))
		L = \$1 * cos(rad(_const))
	"
	X_L = "Radius"
	HEADING = sprintf("klradial %g %g %g %g %g %s", $1,$2,$3,$4,$5,"$6")
	_hklline $1 $2 $3 $4 $5 "$6"
'
def _hklline '
	{_const = $1; _s1 = $2; _f1 = $3; _n1 = int($4); _ctime = $5}

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	_d1 = (_f1 - _s1) / _n1++
	_cols=4
	_sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype = 2
	FPRNT=sprintf("%s  H  K  L  ",X_L)
	PPRNT=""
	for (i=0;i<_numgeo;i++)
		PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(mA[i]))
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")

	{
		local x
		x = _f1
		_hkl x
		if ("$6" != "0")
			$6
		calcA
		_bad_lim = 0
		_hkl_lim
		if (_bad_lim) {
			eprintf("(H K L = %g %g %g)\n", H, K, L)
			exit
		}
	}
	if (_pre_chk) for (i=0; i<_n1; i++) {
		local x
		x = _s1 + i * _d1
		_hkl x
		if ("$6" != "0")
			$6
		calcA
		_bad_lim = 0
		_hkl_lim
		if (_bad_lim) {
			eprintf("(H K L = %g %g %g)\n", H, K, L)
			exit
		}
	}

	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i x h_ca k_ca l_ca
		_x = _s1 + NPTS * _d1
		_hkl _x
		if ("$6" != "0")
			$6
		h_ca = H; k_ca = K; l_ca = L
		get_angles; calcA
		scan_move
		FPRNT=sprintf("%g %g %g %g ",_x,h_ca,k_ca,l_ca)
		PPRNT=""
		for (i=0;i<_numgeo;i++)
			PPRNT=sprintf("%s%8.4f ",PPRNT,A[mA[i]])
		VPRNT=sprintf("%10.5g %10.5g %10.5g ",h_ca,k_ca,l_ca)
		scan_loop
		scan_data(NPTS,_x)
		H = h_ca; K = k_ca; L = l_ca
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'
#########################################################################
#
# `tscan' is a temperature scan.  "scan_move" is included in loop for
#  powder mode to rock motors during a tscan.
#
def tscan '
	if ($# < 4) {
		eprint "Usage:  tscan start finish intervals time [sleep]"
		exit
	} 
	{ _s1 = $1; _f1 = $2; _n1 = int($3); _ctime = $4; _stime = $5; }

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	HEADING = sprintf("tscan %g %g %g %g %g", $1, $2, $3, $4, $5)
	_d1 = (_f1 - _s1) / _n1++
	_cols=1
	_sx = _s1; _fx = _f1
	X_L = "Measured"
	Y_L = cnt_name(DET)
	_stype = 4
	FPRNT="Setpoint  "
	PPRNT=sprintf("%9.9s ", "Setpoint")
	VPRNT=sprintf("%9.9s %9.9s ", "Setpoint", "DegC")
	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		settemp _s1+NPTS*_d1
		do_sleep _stime
		scan_move
		FPRNT=sprintf("%g ",TEMP_SP)
		PPRNT=sprintf("%9.4g ",TEMP_SP)
		VPRNT=sprintf("%9.4f %9.4f ",TEMP_SP,DEGC_SP)
		scan_loop
		scan_data(NPTS, DEGC)
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'

#########################################################################
#
# The following scans are defined in terms of the more basic scans
# above.
#

# The cleanup macro for delta scans returns the motor(s) to the
# starting position(s).

def dscan_cleanup '{
	local   i, m[], n, mne

	n = split("$*", m)

	# following kludge until we get an eval() function
	if (n >= 2)  m[1] = $2
	if (n >= 4)  m[3] = $4
	if (n >= 6)  m[5] = $6
	if (n >= 8)  m[7] = $8
	if (n >= 10) m[9] = $10

	printf("\n")
	ifp {
		fprintf(PRINTER, "\n")
	}
	waitmove
	get_angles
	for (i = 0; i < n; i += 2) {
		mne = motor_mne(motor_num(m[i]))
		printf("Returning %s to %g\n", mne, m[i+1])
		ifp {
			fprintf(PRINTER,"mv %s %g\n", mne, m[i+1])
		}
		A[motor_num(m[i])] = m[i+1]
	}
	_move
	printf("\n")
}'

# delta angle scan (ascan relative to current position)
def lup '
	if ($# != 5) {
		eprint "Usage:  lup motor start finish intervals time"
		exit
	} 
	dscan $*
'
def dscan '
	if ($# != 5) {
		eprint "Usage:  dscan motor start finish intervals time"
		exit
	} 
	_check0 "$1"
	waitall
	get_angles
	_c1=A[$1]

	cdef("cleanup_once", sprintf("dscan_cleanup $1 %s;", _c1), "dscan")

	ascan $1 _c1+($2) _c1+($3) $4 $5

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1
'
# Two motor dscan
def d2scan '
	if ($# != 8) {
		eprint "\
Usage:  d2scan  motor1 start1 finish1  motor2 start2 finish2  intervals time"
		exit
	} 
	_check0 "$1" ; _check0 "$4"
	waitall
	get_angles
	_c1=A[$1]
	_c2=A[$4]

	cdef("cleanup_once",\
		    sprintf("dscan_cleanup $1 %s $4 %s;", _c1, _c2), "dscan")

	a2scan $1 _c1+($2) _c1+($3) $4 _c2+($5) _c2+($6) $7 $8

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1 $4 _c2
'
# Three motor dscan
def d3scan '
	if ($# != 11) {
		eprint "\
Usage:  d3scan  motor1 start1 finish1  m2 s2 f2  m3 s3 f3  intervals time"
		exit
	} 
	_check0 "$1" ; _check0 "$4" ; _check0 "$7"
	waitall
	get_angles
	_c1=A[$1]
	_c2=A[$4]
	_c3=A[$7]

	cdef("cleanup_once",\
	   sprintf("dscan_cleanup $1 %s $4 %s $7 %s;", _c1,_c2,_c3), "dscan")

	a3scan $1 _c1+($2) _c1+($3) $4 _c2+($5) _c2+($6) \
				       $7 _c3+($8) _c3+($9) $10 $11

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1 $4 _c2 $7 _c3
'
# Four motor dscan
def d4scan '
	if ($# != 14) {
		eprint "\
Usage:  d4scan  m1 s1 f1  m2 s2 f2  m3 s3 f3  m4 s4 f4  intervals time"
		exit
	} 
	_check0 "$1" ; _check0 "$4" ; _check0 "$7" ; _check0 "$10"
	waitall
	get_angles
	_c1=A[$1]
	_c2=A[$4]
	_c3=A[$7]
	_c4=A[$10]

	cdef("cleanup_once",\
	 sprintf("dscan_cleanup $1 %s $4 %s $7 %s $10 %s;", _c1,_c2,_c3,_c4),\
	   "dscan")

	a4scan $1 _c1+($2) _c1+($3) $4 _c2+($5) _c2+($6) \
		      "$7" _c3+($8) _c3+($9) "$10" _c4+($11) _c4+($12) $13 $14

	cdef("cleanup_once", "", "dscan", "delete")
	dscan_cleanup $1 _c1 $4 _c2 $7 _c3 $10 _c4
'
def th2th '
	if ($# != 4) {
	    eprint "Usage:  th2th tth_start_rel tth_finish_rel intervals time"
	    exit
	} 
	d2scan tth $1 $2 th ($1)/2 ($2)/2 $3 $4
'
# H scan
def hscan '
	if ($# != 4) {
		eprint "Usage:  hscan start finish intervals time"
		exit
	} 
	waitall; get_angles; calcHKL
	hklscan $1 $2 K K L L $3 $4
'
# K scan
def kscan '
	if ($# != 4) {
		eprint "Usage:  kscan start finish intervals time"
		exit
	} 
	waitall; get_angles; calcHKL
	hklscan H H $1 $2 L L $3 $4
'
# L scan
def lscan '
	if ($# != 4) {
		eprint "Usage:  lscan start finish intervals time"
		exit
	} 
	waitall; get_angles; calcHKL
	hklscan H H K K $1 $2 $3 $4
'
# delta-temperature scan (tscan relative to current position)
def dtscan '
	if ($# != 4 && $# != 5) {
		eprint "Usage:  dtscan start finish intervals time [sleep]"
		exit
	} 
	tscan TEMP_SP+($1) TEMP_SP+($2) $3 $4 $5
'
