# traj_scans1.mac
# Scan helper macros for trajectory scanning with EPICS and the MM4005
#
# This file provides replacements for the following macros in the standard SPEC
# macro file "scans1.mac"
#   _ascan
#   _restart
#   scan_loop
#
# It adds the following new macros:
#   traj_build
#   traj_exec
#   traj_read_counts
#   traj_read_actual
#
# Mark Rivers
# August 16, 2000
#
#########################################################################

#########################################################################
#
#                        SCAN-HELPER MACROS
#
#########################################################################
#
#  _ascan scans the number of motors given by _nm.
#  The arrays _m[], _s[], _f[] and _d[] contain the motor
#  numbers, start, finish and step sizes for each of the
#  scanned motors.  The macros ascan, a2scan, a3scan and
#  a4scan call _ascan.
#
def _ascan '
        if (_n1 <= 0) {
                eprint "Intervals <= 0"
                exit
        } ;
        {
         local i tm
         for (i=0;i<_nm;i++) {
                 _bad_lim = 0
                 _chk_lim _m[i] _s[i]
                 _chk_lim _m[i] _f[i]
                 if (_bad_lim) exit;
                _chk_traj i tm
                if (tm < 0) exit
                
         }
        }
        HEADING=_nm>1? sprintf("a%dscan ", _nm):"ascan "
        {
         local i
         for (i=0;i<_nm;i++) {
                HEADING=sprintf("%s%s",HEADING,sprintf(" %s %g %g ",\
                        motor_mne(_m[i]),_s[i],_f[i]))
                _d[i] = (_f[i] - _s[i]) / _n1
         }
        }
        HEADING=sprintf("%s %g %g",HEADING,_n1,_ctime)
        _n1++
        _cols=_nm+_hkl_col
        X_L = motor_name(_m[0])
        Y_L = cnt_name(DET)
        _sx = _s[0]; _fx = _f[0]
        _stype = 1|(_nm<<8)
        FPRNT=PPRNT=VPRNT=""
        {
         local i
         for (i=0;i<_nm;i++) {
             FPRNT=sprintf("%s%s  ",FPRNT,motor_name(_m[i]))
             PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(_m[i]))
             VPRNT=sprintf("%s%9.9s ",VPRNT,motor_name(_m[i]))
         }
        }
        FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
        scan_head
        PFMT=sprintf("%%s%%8.%df ",UP)
        VFMT=sprintf("%%s%%9.%df ",UP)
        def _scan_on \'
         # Move to start position of scan
         for (i=0;i<_nm;i++) A[_m[i]] = _s[i]
         scan_move
         # Build trajectory
         
         for (; NPTS < _n1; NPTS++) {
                local i
                FPRNT=PPRNT=VPRNT=""
                for (i=0;i<_nm;i++) {
                     FPRNT=sprintf("%s%.8g ",FPRNT,A[_m[i]])
                     PPRNT=sprintf(PFMT,PPRNT,A[_m[i]])
                     VPRNT=sprintf(VFMT,VPRNT,A[_m[i]])
                }
                FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
                scan_loop
                scan_data(NPTS,A[_m[0]])
                scan_plot
         }
         scan_tail
        \'
        _scan_on
'

# Cleanup macro used by all of the scans.
def _scanabort '
        _cleanup2
        _cleanup3
        comment "Scan aborted after %g points" NPTS
        sync
'
# "resume" restarts aborted scans.  It relies on the user not
#  tampering with the scan loop variables.
#  (_stype&8 indicates a 2D-mesh scan).
def resume '
        if (NPTS >= (_stype&8? _n1*_n2:_n1)) {
                eprint "Last scan appears to be finished."
                exit
        }
        if (($1) && _stype&8)
                eprint "Can\'t change the point number of a mesh scan."
        else
                NPTS += $1
        if (NPTS < 0) NPTS  = 0
        cdef("cleanup_once", "_scanabort;", "scan_cleanup")
        comment "Scan resumed"
        if (PLOT_MODE&1)
                plot_cntl("erase")
        _scan_on
'

# The loop macro, called by all the scans at each iteration
def _loop '{
        local z,i,n
        if (!set_sim(-1) && _sleep) {
                do_sleep _sleep
        }
        measure0
        scan_count _ctime
        measure1
        measure2
        z = _ctime < 0? sec:MON
        T_AV += DEGC;
        if (z >= 0)
                MT_AV += S[z]
        s = sprintf("%3d %s%8.0f ", NPTS,VPRNT,S[DET])

        tty_cntl("resized?")
        n = int((COLS - length(VPRNT) - length(Pout) - 24) / 9)
        if (MON >= 0) {
                s = s sprintf("%8.0f ", S[MON])
                n--
        }
        s = s sprintf("%10.6g ",S[sec])

        for (i=0; i<COUNTERS && n>0; i++) {
                if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
                        s = s sprintf("%8.4g ", S[i])
                        n--
                }
        }

        printf("%s%s\n",s,Pout)

        ifp {
                fprintf(PRINTER,"%3d %s %8.6g ", NPTS,_hkl_val11,S[sec])
                if (MON >= 0)
                        fprintf(PRINTER,"%8.0f ", S[MON])
                fprintf(PRINTER,"%8.0f %s%s\n", S[DET],PPRNT,Pout)
        }
        if (DATAFILE != "") {
                fprintf(DATAFILE,"%s%s%d",FPRNT,Fout,(TIME_END=time())-EPOCH)
                for (i=0;i<COUNTERS;i++)
                        if (i != z && i != DET && is_using_counter(i))
                                fprintf(DATAFILE," %g",S[i])
                if (z >= 0)
                        fprintf(DATAFILE," %g",S[z])
                fprintf(DATAFILE," %g\n",S[DET]);
        }
        user_scan_loop
}'

# traj_index returns the index of a trajectory motor given the index of 
# a SPEC motor.  It returns -1 if the motor is not valid
def traj_index '
    if ($# != 2) {
        eprint "Usage: traj_index spec_motor traj_motor
        exit
    }
    { local i
        $2 = -1
        i = _m[$1]
        if (i > MAX_TRAJ_INDEX) {
            eprintf("invalid motor index in chk_traj=%d\n", i)
        } else {
            i = TRAJ_INDEX[i]
            if (i < 0) {
                eprintf("not valid trajectory motor in chk_traj=%d\n", i)
            } else {
                $2 = i
                traj_motor[$1] = i
            }
        }
    }
'

# traj_build builds a trajectory.  It is passed
#   nels         - number of trajectory elements
#   npts         - number of output pulses
#   move[MAX_TRAJ_MOTOR] - flag for each MM4005 motor, 0=don't move, 1=move
#   traj[MAX_TRAJ_MOTOR*nels] - array of trajectory positions
#   time[nels]   - time for each trajectory element
def traj_build '
    if ($# != 5) {
        eprint "Usage: traj_scan nels npts move traj time"
        exit
    }
    {
        local i, _pv
        _pv = TRAJ_NAME "TimeMode";  epics_put(_pv, "Per Element")
        _pv = TRAJ_NAME "MoveMode";  epics_put(_pv, "Relative")
        _pv = TRAJ_NAME "Nelements"; epics_put(_pv, $1)
        _pv = TRAJ_NAME "Npulses";   epics_put(_pv, $2)
        for (i=0; i<MAX_TRAJ_MOTOR; i++) {
            _pv = TRAJ_MOTOR_NAME[i] "Move"
            epics_put(_pv, $3[i])
            _pv = TRAJ_MOTOR_NAME[i] "Traj" 
            epics_put(_pv, $4[i*$1 : (i+1)*$1-1])
        }
        _pv = TRAJ_NAME "TimeTraj";  epics_put(_pv, $5)
        _pv = TRAJ_NAME "Build";     epics_put(_pv, 1)
        while (epics_get(_pv) == "Busy") sleep(0.1)
    }
'

# traj_exec executes a trajectory.
def traj_exec '
    {
        local _pv
        _pv = TRAJ_NAME "Execute"; epics_put(_pv, 1)
        while (epics_get(_pv) == "Busy") sleep(0.1)
    }
'
# traj_read_counts reads the counts from the MCS
# It is passed ndets, npts and counts
# It returns packed data in a single array for ndets
def traj_read_counts '
    if ($# != 3) {
        eprint "Usage: traj_read_counts ndets npts counts"
        exit
    }
    {
        local i, _ndets, _npts
        _ndets=$1; _npts=$2
        for (i=0; i<_ndets; i++) {
            $3[i*_npts : (i+1)*_npts-1] = epics_get(TRAJ_MCS_NAME[i])
        }
    }
'
# traj_read_actual reads the actual motor positions from the trajectory
# It returns packed data in a single array for all motors
def traj_read_actual '
    if ($# != 2) {
        eprint "Usage: traj_read_actual npts actual"
        exit
    }
    {
        local i, _pv, _npts
        _npts=$1
        _pv = TRAJ_NAME "Readback"; epics_put(_pv, 1)
        while (epics_get(_pv) == "Busy") sleep(0.1)
        for (i=0; i<MAX_TRAJ_MOTOR; i++) {
            _pv = TRAJ_MOTOR_NAME[i] "Actual"
            $2[i*_npts : (i+1)*_npts-1] = epics_get(_pv)
        }
    }
'
            
# Trajectory scan globals
# These are site-specific
global IOC_PREFIX
global MAX_TRAJ_MOTOR
global TRAJ_NAME
global TRAJ_MOTOR_NAME
global TRAJ_USE_ACTUAL
IOC_PREFIX = "13IDC:"
TRAJ_NAME = IOC_PREFIX "traj1"
MAX_TRAJ_MOTOR = 8
MIN_TRAJ_ELEMENTS = 4
TRAJ_USE_ACTUAL = 0
TRAJ_MOTOR_NAME[0] = TRAJ_NAME "M1"
TRAJ_MOTOR_NAME[1] = TRAJ_NAME "M2"
TRAJ_MOTOR_NAME[2] = TRAJ_NAME "M3"
TRAJ_MOTOR_NAME[3] = TRAJ_NAME "M4"
TRAJ_MOTOR_NAME[4] = TRAJ_NAME "M5"
TRAJ_MOTOR_NAME[5] = TRAJ_NAME "M6"
TRAJ_MOTOR_NAME[6] = TRAJ_NAME "M7"
TRAJ_MOTOR_NAME[7] = TRAJ_NAME "M8"

TRAJ_MCS_NAME[0]   = IOC_PREFIX "str:mca1"
TRAJ_MCS_NAME[1]   = IOC_PREFIX "str:mca2"
TRAJ_MCS_NAME[2]   = IOC_PREFIX "str:mca3"
TRAJ_MCS_NAME[3]   = IOC_PREFIX "str:mca4"
TRAJ_MCS_NAME[4]   = IOC_PREFIX "str:mca5"
TRAJ_MCS_NAME[5]   = IOC_PREFIX "str:mca6"
TRAJ_MCS_NAME[6]   = IOC_PREFIX "str:mca7"
TRAJ_MCS_NAME[7]   = IOC_PREFIX "str:mca8"

# This table gives the TRAJ motor corresponding to each SPEC motor
global MAX_TRAJ_INDEX
MAX_TRAJ_INDEX = 8
global TRAJ_INDEX
TRAJ_INDEX[0] = 4  # Two theta
TRAJ_INDEX[1] = -1 # Eulerian theta
TRAJ_INDEX[2] = -1 # Eulerian chi
TRAJ_INDEX[3] = -1 # Eulerian phi
TRAJ_INDEX[4] = 2  # Kappa theta
TRAJ_INDEX[5] = 1  # Kappa
TRAJ_INDEX[6] = 0  # Kappa phi
TRAJ_INDEX[7] = -1 # Unused

global traj_motor
