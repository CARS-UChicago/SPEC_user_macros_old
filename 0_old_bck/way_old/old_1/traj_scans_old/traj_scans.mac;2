#########################################################################
#
# `mesh' is a two-motor nested scan
#
def mesh '
	if ($# != 9) {
		eprint "\
Usage:  mesh  mot1 s1 f1 intervals1  mot2 s2 f2 intervals2  time"
		exit
	} 
	_check0 "$1"; _check0 "$5"
	{
		_m[0] = $1; _s1 = $2; _f1 = $3; _n1 = int($4)
		_m[1] = $5; _s2 = $6; _f2 = $7; _n2 = int($8)
		_ctime = $9
	}
	if (_n1 <= 0 || _n2 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	_bad_lim = 0
	_chk_lim _m[0] _s1
	_chk_lim _m[0] _f1
	_chk_lim _m[1] _s2
	_chk_lim _m[1] _f2
	if (_bad_lim) exit

	HEADING = sprintf("mesh  $1 %g %g %g  $5 %g %g %g  %g",\
			$2, $3, $4, $6, $7, $8, $9)

	_d1 = (_f1 - _s1) / _n1++; _d2 = (_f2 - _s2) / _n2++
	_nm=2
	_cols=2+_hkl_col
	X_L = "$1"; _sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype = 1|8|(2<<8)
	FPRNT=sprintf("%s  %s  ",motor_name(_m[0]),motor_name(_m[1]))
	PPRNT=sprintf("%8.8s %8.8s ",motor_name(_m[0]),motor_name(_m[1]))
	VPRNT=sprintf("%9.9s %9.9s ",motor_name(_m[0]),motor_name(_m[1]))
	FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
	scan_head
	PFMT=sprintf("%%8.%df %%8.%df ",UP,UP)
	VFMT=sprintf("%%9.%df %%9.%df ",UP,UP)
	_g1 = _n1
	_g2 = 0
	def _scan_on \'
	 for (; _g2 < _n2; _g2++){
		A[_m[1]] = _s2 + _g2 * _d2
		if (_g1 == _n1)
			_g1 = 0
		for (; _g1 < _n1; _g1++, NPTS++) {
			A[_m[0]] = _s1 + _g1 * _d1
			scan_move
			FPRNT=sprintf("%.8g %.8g ",A[_m[0]],A[_m[1]])
			PPRNT=sprintf(PFMT,A[_m[0]],A[_m[1]])
			VPRNT=sprintf(VFMT,A[_m[0]],A[_m[1]])
			FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
			scan_loop
			scan_data(_g1,A[_m[0]])
			scan_plot
		}
	 }
	 scan_tail
	\'
	_scan_on
'

#########################################################################
#
# `hklscan' is a general linear reciprocal space scan
# (Limit checking is done at the last point first, since limits
# are often exceeded at the extreme points of a scan.)
def hklscan '
	if ($# != 8) {
		eprint "\
Usage:  hklscan Hstart Hfinish Kstart Kfinish Lstart Lfinish intervals time"
		exit
	} 
	{
		_s1 = $1; _f1 = $2; _s2 = $3; _f2 = $4; _s3 = $5; _f3 = $6
		_n1 = int($7); _ctime = $8
	}

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 
	HEADING = sprintf("hklscan  %g %g  %g %g  %g %g  %g %g", $1,$2,$3,\
		$4,$5,$6,$7,$8)
	_d1 = (_f1 - _s1)/_n1
	_d2 = (_f2 - _s2)/_n1
	_d3 = (_f3 - _s3)/_n1++

	H=_f1; K=_f2; L=_f3
	calcA; _bad_lim=0; _hkl_lim
	if (_bad_lim) {
		eprintf("(H K L = %g %g %g)\n",H,K,L)
		exit
	}
	if (_pre_chk) {
		local i
		for (i=0;i<_n1;i++) {
			H = _s1 + i*_d1
			K = _s2 + i*_d2
			L = _s3 + i*_d3
			calcA
			_bad_lim = 0
			_hkl_lim
			if (_bad_lim) {
				eprintf("(H K L = %g %g %g)\n",H,K,L)
				exit
			}
		}
	}
	_cols=3
	if (_d3)
		{ X_L = "L"; _sx = _s3; _fx = _f3 }
	else if (_d2)
		{ X_L = "K"; _sx = _s2; _fx = _f2 }
	else
		{ X_L = "H"; _sx = _s1; _fx = _f1 }
	Y_L = cnt_name(DET)
	_stype = 2
	FPRNT="H  K  L  "
	PPRNT=""
	{
	 local i
	 for (i=0;i<_numgeo;i++)
		PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(mA[i]))
	}
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")
	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i h_ca k_ca l_ca
		H = h_ca = _s1 + NPTS*_d1
		K = k_ca = _s2 + NPTS*_d2
		L = l_ca = _s3 + NPTS*_d3
		get_angles; calcA
		scan_move
		FPRNT=sprintf("%g %g %g ",h_ca,k_ca,l_ca)
		PPRNT=""
		for (i=0;i<_numgeo;i++)
			PPRNT=sprintf("%s%8.4f ",PPRNT,A[mA[i]])
		VPRNT=sprintf("%10.5g %10.5g %10.5g ",h_ca,k_ca,l_ca)
		scan_loop
		scan_data(NPTS,_d3? l_ca:(_d2? k_ca:h_ca))
		H=h_ca; K=k_ca; L=l_ca
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'
#########################################################################
#
# `hklmesh' is a two-Q nested scan.  It uses the fact that H, K and L
# are defined as Q[0], Q[1] and Q[2], respectively.
#
def hklmesh '
	_m1 = index("HKL", "$1")
	_m2 = index("HKL", "$5")
	if ($# != 9 || !_m1 || !_m2 || _m1 == _m2) {
		eprint "\
Usage:  hklmesh  Q1 s1 f1 intervals1  Q2 s2 f2 intervals2  time\n\
	Q1 and Q2 are H, K or L.  Q1 != Q2"
		exit
	}
	waitall; get_angles; calcHKL
	{
		_m1--; _s1 = $2; _f1 = $3; _n1 = int($4)
		_m2--; _s2 = $6; _f2 = $7; _n2 = int($8)
		_ctime = $9
	}
	if (_n1 <= 0 || _n2 <= 0) {
		eprint "Intervals <= 0"
		exit
	}

	HEADING = sprintf("hklmesh  $1 %g %g %g  $5 %g %g %g  %g",\
			$2,$3,$4,$6,$7,$8,$9)

	_d1 = (_f1 - _s1) / _n1++; _d2 = (_f2 - _s2) / _n2++
	if (_pre_chk) {
		local i j
		for (i=0; i<_n2; i++) {
			Q[_m2] = _s2 + i * _d2
			for (j=0; j<_n1; j++) {
				Q[_m1] = _s1 + j * _d1
				calcA
				_bad_lim = 0
				_hkl_lim
				if (_bad_lim) {
					eprintf("(H K L = %g %g %g)\n", H,K,L)
					exit
				}
				calcHKL
			}
		}
	}
	_cols=3
	X_L = "$1"; _sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype=2|8
	FPRNT="H  K  L  "
	PPRNT=""
	{
	 local i
	 for (i=0;i<_numgeo;i++)
		PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(mA[i]))
	}
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")
	scan_head
	_hklmesh
'
# Long macro definition requires 2 parts
#  save Q[_m3] at start of mesh and restore at each point to prevent drift
def _hklmesh '
	_m3 = 3 - _m1 - _m2
	_g1 = _n1
	_g2 = 0
	def _scan_on \'
	 {
	  local _ca
	  _ca[_m3] = Q[_m3]
	  for (; _g2 < _n2; _g2++){
		Q[_m2] = _ca[_m2] = _s2 + _g2 * _d2
		if (_g1 == _n1)
			_g1 = 0
		for (; _g1 < _n1; _g1++, NPTS++) {
			local i
			Q[_m1] = _ca[_m1] = _s1 + _g1 * _d1
			Q[_m3] = _ca[_m3]
			get_angles; calcA
			scan_move
			FPRNT=sprintf("%g %g %g ", _ca[0],_ca[1],_ca[2])
			PPRNT=""
			for (i=0;i<_numgeo;i++)
				PPRNT=sprintf("%s%8.4f ",PPRNT,A[mA[i]])
			VPRNT=sprintf("%10.5g %10.5g %10.5g ",\
							_ca[0],_ca[1],_ca[2])
			scan_loop
			scan_data(_g1,_ca[_m1])
			scan_plot
		}
	  }
	 }
	 scan_tail
	\'
	_scan_on
'


def _hklline '
	{_const = $1; _s1 = $2; _f1 = $3; _n1 = int($4); _ctime = $5}

	if (_n1 <= 0) {
		eprint "Intervals <= 0"
		exit
	} 

	_d1 = (_f1 - _s1) / _n1++
	_cols=4
	_sx = _s1; _fx = _f1
	Y_L = cnt_name(DET)
	_stype = 2
	FPRNT=sprintf("%s  H  K  L  ",X_L)
	PPRNT=""
	for (i=0;i<_numgeo;i++)
		PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(mA[i]))
	VPRNT=sprintf("%10s %10s %10s ","H","K","L")

	{
		local x
		x = _f1
		_hkl x
		if ("$6" != "0")
			$6
		calcA
		_bad_lim = 0
		_hkl_lim
		if (_bad_lim) {
			eprintf("(H K L = %g %g %g)\n", H, K, L)
			exit
		}
	}
	if (_pre_chk) for (i=0; i<_n1; i++) {
		local x
		x = _s1 + i * _d1
		_hkl x
		if ("$6" != "0")
			$6
		calcA
		_bad_lim = 0
		_hkl_lim
		if (_bad_lim) {
			eprintf("(H K L = %g %g %g)\n", H, K, L)
			exit
		}
	}

	scan_head
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i x h_ca k_ca l_ca
		_x = _s1 + NPTS * _d1
		_hkl _x
		if ("$6" != "0")
			$6
		h_ca = H; k_ca = K; l_ca = L
		get_angles; calcA
		scan_move
		FPRNT=sprintf("%g %g %g %g ",_x,h_ca,k_ca,l_ca)
		PPRNT=""
		for (i=0;i<_numgeo;i++)
			PPRNT=sprintf("%s%8.4f ",PPRNT,A[mA[i]])
		VPRNT=sprintf("%10.5g %10.5g %10.5g ",h_ca,k_ca,l_ca)
		scan_loop
		scan_data(NPTS,_x)
		H = h_ca; K = k_ca; L = l_ca
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'
