# traj_scans1.mac
# Scan helper macros for trajectory scanning with EPICS and the MM4005
#
# This file provides replacements for the following macros in the standard SPEC
# macro file "scans1.mac"
#   _ascan
#   _restart
#   scan_loop
#
# Mark Rivers
# August 16, 2000
#
#########################################################################

#########################################################################
#
#                        SCAN-HELPER MACROS
#
#########################################################################
#
#  _ascan scans the number of motors given by _nm.
#  The arrays _m[], _s[], _f[] and _d[] contain the motor
#  numbers, start, finish and step sizes for each of the
#  scanned motors.  The macros ascan, a2scan, a3scan and
#  a4scan call _ascan.
#
def _ascan '
        if (_n1 <= 0) {
                eprint "Intervals <= 0"
                exit
        } ;
        {
         local i
         for (i=0;i<_nm;i++) {
                 _bad_lim = 0
                 _chk_lim _m[i] _s[i]
                 _chk_lim _m[i] _f[i]
                 if (_bad_lim) exit;
         }
        }
        HEADING=_nm>1? sprintf("a%dscan ", _nm):"ascan "
        {
         local i
         for (i=0;i<_nm;i++) {
                HEADING=sprintf("%s%s",HEADING,sprintf(" %s %g %g ",\
                        motor_mne(_m[i]),_s[i],_f[i]))
                _d[i] = (_f[i] - _s[i]) / _n1
         }
        }
        HEADING=sprintf("%s %g %g",HEADING,_n1,_ctime)
        _n1++
        _cols=_nm+_hkl_col
        X_L = motor_name(_m[0])
        Y_L = cnt_name(DET)
        _sx = _s[0]; _fx = _f[0]
        _stype = 1|(_nm<<8)
        FPRNT=PPRNT=VPRNT=""
        {
         local i
         for (i=0;i<_nm;i++) {
             FPRNT=sprintf("%s%s  ",FPRNT,motor_name(_m[i]))
             PPRNT=sprintf("%s%8.8s ",PPRNT,motor_name(_m[i]))
             VPRNT=sprintf("%s%9.9s ",VPRNT,motor_name(_m[i]))
         }
        }
        FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
        scan_head
        PFMT=sprintf("%%s%%8.%df ",UP)
        VFMT=sprintf("%%s%%9.%df ",UP)
        def _scan_on \'
         for (; NPTS < _n1; NPTS++) {
                local i
                for (i=0;i<_nm;i++)
                        A[_m[i]] = _s[i] + NPTS * _d[i]
                scan_move
                FPRNT=PPRNT=VPRNT=""
                for (i=0;i<_nm;i++) {
                     FPRNT=sprintf("%s%.8g ",FPRNT,A[_m[i]])
                     PPRNT=sprintf(PFMT,PPRNT,A[_m[i]])
                     VPRNT=sprintf(VFMT,VPRNT,A[_m[i]])
                }
                FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
                scan_loop
                scan_data(NPTS,A[_m[0]])
                scan_plot
         }
         scan_tail
        \'
        _scan_on
'

# Cleanup macro used by all of the scans.
def _scanabort '
        _cleanup2
        _cleanup3
        comment "Scan aborted after %g points" NPTS
        sync
'
# "resume" restarts aborted scans.  It relies on the user not
#  tampering with the scan loop variables.
#  (_stype&8 indicates a 2D-mesh scan).
def resume '
        if (NPTS >= (_stype&8? _n1*_n2:_n1)) {
                eprint "Last scan appears to be finished."
                exit
        }
        if (($1) && _stype&8)
                eprint "Can\'t change the point number of a mesh scan."
        else
                NPTS += $1
        if (NPTS < 0) NPTS  = 0
        cdef("cleanup_once", "_scanabort;", "scan_cleanup")
        comment "Scan resumed"
        if (PLOT_MODE&1)
                plot_cntl("erase")
        _scan_on
'

# The loop macro, called by all the scans at each iteration
def _loop '{
        local z,i,n
        if (!set_sim(-1) && _sleep) {
                do_sleep _sleep
        }
        measure0
        scan_count _ctime
        measure1
        measure2
        z = _ctime < 0? sec:MON
        T_AV += DEGC;
        if (z >= 0)
                MT_AV += S[z]
        s = sprintf("%3d %s%8.0f ", NPTS,VPRNT,S[DET])

        tty_cntl("resized?")
        n = int((COLS - length(VPRNT) - length(Pout) - 24) / 9)
        if (MON >= 0) {
                s = s sprintf("%8.0f ", S[MON])
                n--
        }
        s = s sprintf("%10.6g ",S[sec])

        for (i=0; i<COUNTERS && n>0; i++) {
                if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
                        s = s sprintf("%8.4g ", S[i])
                        n--
                }
        }

        printf("%s%s\n",s,Pout)

        ifp {
                fprintf(PRINTER,"%3d %s %8.6g ", NPTS,_hkl_val11,S[sec])
                if (MON >= 0)
                        fprintf(PRINTER,"%8.0f ", S[MON])
                fprintf(PRINTER,"%8.0f %s%s\n", S[DET],PPRNT,Pout)
        }
        if (DATAFILE != "") {
                fprintf(DATAFILE,"%s%s%d",FPRNT,Fout,(TIME_END=time())-EPOCH)
                for (i=0;i<COUNTERS;i++)
                        if (i != z && i != DET && is_using_counter(i))
                                fprintf(DATAFILE," %g",S[i])
                if (z >= 0)
                        fprintf(DATAFILE," %g",S[z])
                fprintf(DATAFILE," %g\n",S[DET]);
        }
        user_scan_loop
}'

# traj_build builds a trajectory.  It is passed
#   move[8]      - a flag for each MM4005 motor, 0=don't move, 1=move
#   traj[8*nels] - an array of trajectory positions
#   npts         - number of output pulses
#   time         - total time for trajectory
def traj_build '
    if ($# != 5) {
        eprint "Usage: traj_scan move traj nels npts time"
        exit
    }
    {
        local i, _move, _traj, _nels, _npts, _time, _pv, _status
        _nels = $3; _npts = $4; _time = $5
        for (i=0; i<MAX_TRAJ_MOTOR; i++) {
            _pv = TRAJ_MOTOR_NAME[i] "Move"
            epics_put(_pv, $1[i])
            _pv = TRAJ_MOTOR_NAME[i] "Traj" 
            epics_put(_pv, $2[i*_nels : (i+1)*_nels-1])
        }
        _pv = TRAJ_NAME "Nelements"; epics_put(_pv, _nels)
        _pv = TRAJ_NAME "Npulses";   epics_put(_pv, _npts)
        _pv = TRAJ_NAME "Time";      epics_put(_pv, _time)
        _pv = TRAJ_NAME "TimeMode";  epics_put(_pv, "Total")
        _pv = TRAJ_NAME "MoveMode";  epics_put(_pv, "Relative")
        _pv = TRAJ_NAME "Build";     epics_put(_pv, 1)
        while (epics_get(_pv) == "Busy") sleep(0.1)
    }
'

# traj_exec executes a trajectory.
def traj_exec '
    {
        local _pv
        _pv = TRAJ_NAME "Execute"; epics_put(_pv, 1)
        while (epics_get(_pv) == "Busy") sleep(0.1)
    }
'
# traj_read_counts reads the counts from the MCS
# It is passed ndets, npts and counts
# It returns packed data in a single array for ndets
def traj_read_counts '
    {
    if ($# != 3) {
        eprint "Usage: traj_read_counts ndets npts counts"
        exit
    }
    {
        local i, _pv, _ndets, _npts
        _ndets=$1; _npts=$2
        for (i=0; i<_ndets; i++) {
            $3[i*_npts : (i+1)*_npts-1] = epics_get(TRAJ_MCS_NAME[i])
        }
    }
'
            
# Trajectory scan globals
global IOC_PREFIX
global MAX_TRAJ_MOTOR
global TRAJ_NAME
global TRAJ_MOTOR_NAME
IOC_PREFIX = "13IDC:"
TRAJ_NAME = IOC_PREFIX "traj1"
MAX_TRAJ_MOTOR = 8
TRAJ_MOTOR_NAME[0] = TRAJ_NAME "M1"
TRAJ_MOTOR_NAME[1] = TRAJ_NAME "M2"
TRAJ_MOTOR_NAME[2] = TRAJ_NAME "M3"
TRAJ_MOTOR_NAME[3] = TRAJ_NAME "M4"
TRAJ_MOTOR_NAME[4] = TRAJ_NAME "M5"
TRAJ_MOTOR_NAME[5] = TRAJ_NAME "M6"
TRAJ_MOTOR_NAME[6] = TRAJ_NAME "M7"
TRAJ_MOTOR_NAME[7] = TRAJ_NAME "M8"

TRAJ_MCS_NAME[0]   = IOC_PREFIX "str:mca1"
TRAJ_MCS_NAME[1]   = IOC_PREFIX "str:mca2"
TRAJ_MCS_NAME[2]   = IOC_PREFIX "str:mca3"
TRAJ_MCS_NAME[3]   = IOC_PREFIX "str:mca4"
TRAJ_MCS_NAME[4]   = IOC_PREFIX "str:mca5"
TRAJ_MCS_NAME[5]   = IOC_PREFIX "str:mca6"
TRAJ_MCS_NAME[6]   = IOC_PREFIX "str:mca7"
TRAJ_MCS_NAME[7]   = IOC_PREFIX "str:mca8"

