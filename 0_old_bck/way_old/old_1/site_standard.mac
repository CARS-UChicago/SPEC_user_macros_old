############################################################################
############################################################################
## site_standard.mac
## Use this to replace standard macros from
##      /usr/lib/spec.d/standard.mac 
##  or add new macros which will be used for any spec version
## 
## Note this file is read on a fresh start of spec 
##     ( either ">psic -f" or ">kappa -f" )
## Before defining a new macro type lsdef in spec to see
## if the name is already defined
##
############################################################################
############################################################################


############################################################################
# traj_scans
# Scan macros for trajectory scanning with EPICS and the MM4005
# This defines macros to turn trajectory scanning on and off

def traj_scans_on '{
    local t
    t = USERMAC "/traj_scans1.mac"
    qdofile(t)
}'

def traj_scans_off '{
    local t
    t = USERMAC "/point_scans1.mac"
    qdofile(t)
}'

############################################################################
def ton ' traj_scans_on '
############################################################################

############################################################################
def toff ' traj_scans_off '
############################################################################

############################################################################
def shell ' unix() '
############################################################################

############################################################################
def sor ' or_swap '
############################################################################

############################################################################
# macro to run a file defined in the USERMAC directory
def do_user_mac '{ 
  local t
  t = USERMAC "/" $1
  qdofile(t)      
}'
############################################################################

############################################################################
# macro to return the sign of a number
def sign(x) '{ 
    if (x < 0) {
       return(-1)
    } else if (x > 0) { 
       return(1)
    } else { 
      return(0)
    }      
}'
############################################################################

############################################################################
# macro to return the square of a number
def square(x) '{ 
      return(x*x)      
}'
############################################################################

############################################################################
# macro to return the fraction part of a real number
def get_frac(x) '{ 
      x = fabs(x);
      if ( x < 1 ) {
         return(x);
      } else {
         return(  x - int(x)  )   
      }   
}'
############################################################################


############################################################################
## expanded this macro so it shows name and mne (vs _mot in standard.mac)
#
# show current (geometry) motor postions, only user units
def _mot '{
	local s[]
	s[0] = "name"
      s[1] = "mne"
	s[2] = "user"
	show_motor_info(s, 3, $#==1? $1:MOTORS)
}'
############################################################################


############################################################################
#### changed below macro from standard.mac to display 9 motors per line  
#### and add a newline between them
#
# Internal macro used to display motor information at 8 motors per line.
# Listing of motors named "unused" or that are disabled is suppressed.
# First argument is array of info-types as "name", "mne", "user",
# "dial", "lim+", "lim-", "ulim+" and "ulim-".  Second argument
# is number of elements in array.  Third argument is number of motors.
# If first argument is a single string as above, that is okay.
def show_motor_info(f, ns, n) '{
    local i, j, k, m, s[], t
    for (i=0; i<n && i<MOTORS; i++) {
	for (k=0;k<ns;k++)
	    s[k]=""
	for (j=0; i<n && i<MOTORS; i++) {
	    if (!is_using_motor(mA[i]))
		continue;
	    for (k=0;k<ns;k++) {
		m = mA[i]
		t = (whatis("f")&0x01000000)? f[k]:f
		if (t =="name")
		    s[k] = s[k] sprintf("%9.9s", motor_name(m))
		else if (t == "mne")
		    s[k] = s[k] sprintf("%9.9s", motor_mne(m))
		else if (t == "user")
		    s[k] = s[k] sprintf("%9.4f", A[m])
		else if (t == "dial")
		    s[k] = s[k] sprintf("%9.4f", dial(m, A[m]))
		else if (t == "lim+")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, +1))
		else if (t == "ulim+")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, +1)))
		else if (t == "lim-")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, -1))
		else if (t == "ulim-")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, -1)))
	    }
	    if (j%9 == 8)
		break
	    for (k=0;k<ns;k++)
		s[k] = s[k] " "
	    j++
	}
	#for (k=0;k<ns;k++)
	#    p s[k] 
      for (k=0;k<ns;k++){
	    p s[k]
      }
      p "\n" 
    }
}'
############################################################################

############################################################################
## user_getcounts
## user_getcounts is called in the macro get_counts 
## defined in standard.mac, its used here to add an 
## epics pv to the scalers
def user_getcounts '{

## put aim_adc1 roi into the last scaler
# need this to wait for mca software to finish the calc
sleep(.3)  
S[5] = epics_get("13IDC:aim_adc1.R0")
#S[5] = epics_get("13IDC:aim_adc1.R0N")
#S[5] = 0

##need a call to dump mca spectra to a file here, 
# if dump mca flag is on 
# build a file name
# call procedure to write the file  

}'
###########################################################################

############################################################################
## user_precount
## executed before a count in standard.mac
## use to make sure the mono feedback is locked
## bf counting
def user_precount '{

if ( epics_get("13IDA:mono_pid1.FBON") ==  "On" ){
   if (epics_get("13IDA:mono_pid1Locked") == 0) printf("Waiting for beam\n")
   while (epics_get("13IDA:mono_pid1Locked") == 0) sleep(0.1)
}

}'
############################################################################


############################################################################
## this is executed after any motor move 
def user_postmove '{ 
# while (epics_get("13IDA:E:Moving") == "Busy") sleep(0.1)
while (epics_get("13IDA:E:Moving") == 1) sleep(0.1)
}'
############################################################################


############################################################################
## add attenuators NOT TESTED 
#def add_atten '{
#  local stat_1 stat_2 stat_3 stat_4   
#   if ($# != 2){
#   eprint "Usage: atten_check mon_val mon_max_val"
#   exit
#   }
# 
#  if ($1 <= $2 ) {
#   exit
#   }
# 
#check status of attenators
#stat_1 = epics_get("13IDC:UnidigBi16.VAL")
#stat_2 = epics_get("13IDC:UnidigBi18.VAL")
#stat_3 = epics_get("13IDC:UnidigBi20.VAL")
#stat_4 = epics_get("13IDC:UnidigBi22.VAL")
#
#
#    if (stat_4 == 0){
#        epics_put("13IDC:UnidigBi23.VAL",1) 
#        printf("4")
#    } else if (stat_3 == 0) {
#        epics_put("13IDC:UnidigBi21.VAL",1)
#        printf("3") 
#    } else if (stat_2 == 0) {
#        epics_put("13IDC:UnidigBi19.VAL",1)
#        printf("2")
#    } else  if (stat_4 == 0) {
#        epics_put("13IDC:UnidigBi18.VAL",1)
#        printf("1)
#    }
#}'
############################################################################



############################################################################
# T2: Add stuff to data files
# (see pg 149 in spec manual)
# the Fheader increments _cols for number of output cols in _loop
# and puts the #X_ ... into the scan header
# Flabel and Fout put extra info into the data cols in _loop 
def Fheader  '_cols = _cols+2; printf("#X_Alpha_Beta %g %g\n", ALPHA, BETA)'
def Flabel  '"Alpha  Beta  "'
def Fout  'sprintf("%7.5g  %7.5g  ", ALPHA, BETA)'  
############################################################################

#########################################################################
# Edit the _head macro to alter the datafile output
# The head macro, called by all the scans.
def _head '
	user_prescan_head
	_scan_time
	waitall; get_angles; calcHKL
	NPTS = T_AV = MT_AV = 0
	DATE = date()
	TIME = TIME_END = time()
	_cp = A[_pmot]
	cdef("cleanup_once", "_scanabort;", "scan_cleanup")

	# DATA FILE HEADER
	if (DATAFILE != "") {
		local i,j,z,s
		ond; offt
		printf("\n#S %d  %s\n#D %s\n",++SCAN_N,HEADING,DATE)
		if (_ctime < 0)
			printf("#M %g  (%s)\n", -_ctime, cnt_name(MON))
		else
			printf("#T %g  (%s)\n", _ctime, cnt_name(sec))


           #T2: print out the geometry data in the scan header
           # added the UB and Q arrays to the output    
		_head_par G 0
		_head_par U 1
		# _head_par M 2
            _head_par UB 3
            _head_par Q 4

		printf("#Q %s\n", _hkl_val)

           #Print current motor positions
		for (i=0; i<MOTORS; i+= 8) {
			s = sprintf("#P%d ",i/8)
			for (j=i; j<i+8 && j<MOTORS;) {
				if (motor_name(mA[j]) != "unused")
					s = s sprintf("%.8g", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
		}

            #Heres where Fheader gets used
		Fheader
		user_Fheader

		z = _ctime < 0? sec:MON
		for (i=j=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				j++
		printf("#N %d\n", _cols + (MON<0? 2:3) + j)
		_cols = 0
		printf("#L %s%sEpoch",FPRNT,Flabel)
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				printf("  %s",cnt_name(i))
		if (z >= 0)
			printf("  %s",cnt_name(z))
		printf("  %s\n",cnt_name(DET))
		offd; ont
	} else
		SCAN_N++
	T_L = sprintf("Scan %d", SCAN_N)

	# PRINTER HEADER
	#ifp {
	#}

	# TTY HEADER
	{
		local i, n, s

		if (DATAFILE == "/dev/null" || DATAFILE == "null")
			s = "**NO DATA FILE**"
		else
			s = sprintf("file = %s", DATAFILE)
		printf("\nScan %3d   %s   %s  %s  user = %s\n%s\n\n",\
			SCAN_N,DATE,s,TITLE,USER,HEADING)
		s = sprintf("  # %s%8.8s ", VPRNT,cnt_name(DET))

		tty_cntl("resized?")
		n = int((COLS - length(VPRNT) - length(Plabel) - 24) / 9)
		if (MON >= 0) {
			s = s sprintf("%8.8s ",cnt_name(MON))
			n--
		}
		s = s sprintf("%10.10s ",cnt_name(sec))

		for (i=0; i<COUNTERS && n>0; i++) {
			if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
				s = s sprintf("%8.8s ", cnt_name(i))
				n--
			}
		}
		printf("%s%s\n",s,Plabel)
	}
	user_postscan_head
'

#########################################################################

#########################################################################
# Used by head to save various geometry parameters
# $1 is parameter name.  $2 is #G suffix
def _head_par '
	if (whatis("$1[0]")) {
		local i
		printf("#G$2")
		for (i=0;;i++)
			if (whatis(sprintf("$1[%d]", i)))
				#printf(" %g", $1[i])
                       printf(" %.10g", $1[i])
			else break
		printf("\n")
	}
'
#########################################################################


