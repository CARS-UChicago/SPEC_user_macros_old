############################################################################
############################################################################
## site_standard.mac
## Use this to replace standard macros from
##      /usr/lib/spec.d/standard.mac 
##  or add new macros which will be used for any spec version
## 
## Note this file is read on a fresh start of spec 
##     ( either ">psic -f" or ">kappa -f" )
## Before defining a new macro type lsdef in spec to see
## if the name is already defined
##
############################################################################

        
############################################################################
# traj_scans
# Scan macros for trajectory scanning with EPICS and the MM4005
# This defines macros to turn trajectory scanning on and off

def traj_scans_on '{
    local t
    t = USERMAC "/traj_scans1.mac"
    qdofile(t)
    IS_TRAJ_SCAN = 1;
}'

def traj_scans_off '{
    local t
    t = USERMAC "/point_scans1.mac"
    qdofile(t)
    IS_TRAJ_SCAN = 0;
}'

############################################################################
def ton ' traj_scans_on '
############################################################################

############################################################################
def toff ' traj_scans_off '
############################################################################

############################################################################
def rs ' do_user_mac("rod_scan.def") '
############################################################################

############################################################################
def sh ' unix() '
############################################################################

############################################################################
def sor ' or_swap '
############################################################################

############################################################################
# macro to run a file defined in the USERMAC directory
def do_user_mac '{ 
  local t
  t = USERMAC "/" $1
  qdofile(t)      
}'
############################################################################

############################################################################
# macro to return the sign of a number
def sign(x) '{ 
    if (x < 0) {
       return(-1)
    } else if (x > 0) { 
       return(1)
    } else { 
      return(0)
    }      
}'
############################################################################

############################################################################
# macro to return the square of a number
def square(x) '{ 
      return(x*x)      
}'
############################################################################

############################################################################
# macro to return the fraction part of a real number
def get_frac(x) '{ 
      x = fabs(x);
      if ( x < 1 ) {
         return(x);
      } else {
         return(  x - int(x)  )   
      }   
}'
############################################################################


############################################################################
## expanded this macro so it shows name and mne (vs _mot in standard.mac)
#
# show current (geometry) motor postions, only user units
def _mot '{
	local s[]
	s[0] = "name"
      s[1] = "mne"
	s[2] = "user"
	show_motor_info(s, 3, $#==1? $1:MOTORS)
}'
############################################################################


############################################################################
#### changed below macro from standard.mac to display 9 motors per line  
#### and add a newline between them
#
# Internal macro used to display motor information at 8 motors per line.
# Listing of motors named "unused" or that are disabled is suppressed.
# First argument is array of info-types as "name", "mne", "user",
# "dial", "lim+", "lim-", "ulim+" and "ulim-".  Second argument
# is number of elements in array.  Third argument is number of motors.
# If first argument is a single string as above, that is okay.
def show_motor_info(f, ns, n) '{
    local i, j, k, m, s[], t
    for (i=0; i<n && i<MOTORS; i++) {
	for (k=0;k<ns;k++)
	    s[k]=""
	for (j=0; i<n && i<MOTORS; i++) {
	    if (!is_using_motor(mA[i]))
		continue;
	    for (k=0;k<ns;k++) {
		m = mA[i]
		t = (whatis("f")&0x01000000)? f[k]:f
		if (t =="name")
		    s[k] = s[k] sprintf("%9.9s", motor_name(m))
		else if (t == "mne")
		    s[k] = s[k] sprintf("%9.9s", motor_mne(m))
		else if (t == "user")
		    s[k] = s[k] sprintf("%9.4f", A[m])
		else if (t == "dial")
		    s[k] = s[k] sprintf("%9.4f", dial(m, A[m]))
		else if (t == "lim+")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, +1))
		else if (t == "ulim+")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, +1)))
		else if (t == "lim-")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, -1))
		else if (t == "ulim-")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, -1)))
	    }
	    if (j%9 == 8)
		break
	    for (k=0;k<ns;k++)
		s[k] = s[k] " "
	    j++
	}
	#for (k=0;k<ns;k++)
	#    p s[k] 
      for (k=0;k<ns;k++){
	    p s[k]
      }
      p "\n" 
    }
}'
############################################################################

############################################################################
## user_getcounts
## user_getcounts is called in the macro get_counts 
## defined in standard.mac, its used here to add an 
## epics pv to the scalers
def user_getcounts '{

## put aim_adc1 roi into the last scaler
# need this to wait for mca software to finish the calc
sleep(.3)  
S[5] = epics_get("13IDC:aim_adc1.R0")
#S[5] = epics_get("13IDC:aim_adc1.R0N")
#S[5] = 0

##need a call to dump mca spectra to a file here, 
# if dump mca flag is on 
# build a file name
# call procedure to write the file  

}'
###########################################################################

############################################################################
## user_precount
## executed before a count in standard.mac, see def of scan_count --> count
## use to make sure the mono feedback is locked
## bf counting
def user_precount '{

if ( epics_get("13IDA:mono_pid1.FBON") ==  "On" ){
   if (epics_get("13IDA:mono_pid1Locked") == 0) printf("Waiting for beam\n")
   while (epics_get("13IDA:mono_pid1Locked") == 0) sleep(0.1)
}

}'
############################################################################

############################################################################
## this is executed after any motor move
## see def of move_em
## wait for feedback to lock after any move ... 
def user_postmove '{ 
# while (epics_get("13IDA:E:Moving") == "Busy") sleep(0.1)
while (epics_get("13IDA:E:Moving") == 1) sleep(0.1)
}'
############################################################################

#########################################################################
# The loop macro, called by all the scans at each iteration
def _loop '{
	local z,i,n

      # if its a point scan we need to get the counts
      # traj scans already has the counts so we can skip this
      if (IS_TRAJ_SCAN == 0) {
	    if (!set_sim(-1) && _sleep) {
              do_sleep _sleep
	    }
          # if its a fake scan get the fake vals
          if (IS_FAKE_SCAN == 1){
             fake_scan_count _ctime
          } else {
 	       measure0
             scan_count _ctime
	       measure1
	       measure2
          }
      }

	z = _ctime < 0? sec:MON
	T_AV += DEGC;
	if (z >= 0)
		MT_AV += S[z]
	s = sprintf("%3d %s%8.0f ", NPTS,VPRNT,S[DET])

	tty_cntl("resized?")
	n = int((COLS - length(VPRNT) - length(Pout) - 24) / 9)
	if (MON >= 0) {
		s = s sprintf("%8.0f ", S[MON])
		n--
	}
	s = s sprintf("%10.6g ",S[sec])

	for (i=0; i<COUNTERS && n>0; i++) {
		if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
			s = s sprintf("%8.4g ", S[i])
			n--
		}
	}

	printf("%s%s\n",s,Pout)

	ifp {
		fprintf(PRINTER,"%3d %s %8.6g ", NPTS,_hkl_val11,S[sec])
		if (MON >= 0)
			fprintf(PRINTER,"%8.0f ", S[MON])
		fprintf(PRINTER,"%8.0f %s%s\n", S[DET],PPRNT,Pout)
	}
	if (DATAFILE != "") {
		fprintf(DATAFILE,"%s%s%d",FPRNT,Fout,(TIME_END=time())-EPOCH)
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				fprintf(DATAFILE," %g",S[i])
		if (z >= 0)
			fprintf(DATAFILE," %g",S[z])
		fprintf(DATAFILE," %g\n",S[DET]);
	}
        user_scan_loop
}'
#########################################################################



############################################################################
# Add stuff to data files
# (see pg 149 in spec manual)
# the Fheader increments _cols for number of output cols in _loop
# and puts the #X_ ... into the scan header
# Flabel and Fout put extra info into the data cols in _loop 

def Fheader  '_cols = _cols+2; 
              if(IS_RS) printf("%s\n", RS_SCAN_TITLE);
              printf("#X_Alpha_Beta %g %g\n", ALPHA, BETA)
             '
def Flabel  '"Alpha  Beta  "'
def Fout  'sprintf("%7.5g  %7.5g  ", ALPHA, BETA)'  

############################################################################

#########################################################################
#
# The head macro, called by all the scans. at the start of the scan....
# ie this initializes the scan data and prints the header etc....
#
def _head '
	user_prescan_head
	_scan_time

      # see if this is a fake scan
      if (IS_FAKE_SCAN == 1){
         # if it is a fake scan see if the motors are really moving
         if ( FS_MOVE == 1) {
              # if yes get the current positions and HKL
              waitall; get_angles; calcHKL
          }
       # if its not a fake scan get the current positions and HKL
       } else {
         waitall; get_angles; calcHKL
       }

	NPTS = T_AV = MT_AV = 0
	DATE = date()
	TIME = TIME_END = time()
	_cp = A[_pmot]
	cdef("cleanup_once", "_scanabort;", "scan_cleanup")

	# DATA FILE HEADER
	if (DATAFILE != "") {
		local i,j,z,s
		ond; offt
		printf("\n#S %d  %s\n#D %s\n",++SCAN_N,HEADING,DATE)
		if (_ctime < 0)
			printf("#M %g  (%s)\n", -_ctime, cnt_name(MON))
		else
			printf("#T %g  (%s)\n", _ctime, cnt_name(sec))

 
           # T2 print out the geometry data in the scan header
           # added the UB and Q arrays to the output    
		_head_par G 0
		_head_par U 1
		# _head_par M 2
            _head_par UB 3
            _head_par Q 4

		printf("#Q %s\n", _hkl_val)

		for (i=0; i<MOTORS; i+= 8) {
			s = sprintf("#P%d ",i/8)
			for (j=i; j<i+8 && j<MOTORS;) {
				if (motor_name(mA[j]) != "unused")
					s = s sprintf("%.8g", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
		}
		Fheader
		user_Fheader
		z = _ctime < 0? sec:MON
		for (i=j=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				j++
		printf("#N %d\n", _cols + (MON<0? 2:3) + j)
		_cols = 0
		printf("#L %s%sEpoch",FPRNT,Flabel)
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				printf("  %s",cnt_name(i))
		if (z >= 0)
			printf("  %s",cnt_name(z))
		printf("  %s\n",cnt_name(DET))
		offd; ont
	} else
		SCAN_N++
	T_L = sprintf("Scan %d", SCAN_N)

	# PRINTER HEADER
	ifp {
		local i, j, k, s
		onp; offt
		printf("\n")
		formfeed
		printf("\nScan %3d   %s   file = %s  %s  user = %s\n",\
			SCAN_N,DATE,DATAFILE,TITLE,USER)
		printf("%s\n\n",HEADING)
		for (i=0; i<MOTORS; i+=8) {
			s = "  "
			for (j=i; j<i+8 && j<MOTORS;) {
				if (is_using_motor(mA[j]))
					s = s sprintf("%9.9s", motor_name(mA[j]))
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
			s = "  "
			for (j=i; j<i+8 && j<MOTORS;) {
				if (is_using_motor(mA[j]))
					s = s sprintf("%9.6g ", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
		}
		Pheader
		user_Pheader
		printf("\n  # %s %8.8s ", _hkl_sym11,cnt_name(sec))
		if (MON >= 0)
			printf("%8.8s ", cnt_name(MON))
		printf("%8.8s %s%s\n", cnt_name(DET),PPRNT,Plabel)
		offp; ont
	}
	# TTY HEADER
	{
		local i, n, s

		if (DATAFILE == "/dev/null" || DATAFILE == "null")
			s = "**NO DATA FILE**"
		else
			s = sprintf("file = %s", DATAFILE)
		printf("\nScan %3d   %s   %s  %s  user = %s\n%s\n\n",\
			SCAN_N,DATE,s,TITLE,USER,HEADING)
		s = sprintf("  # %s%8.8s ", VPRNT,cnt_name(DET))

		tty_cntl("resized?")
		n = int((COLS - length(VPRNT) - length(Plabel) - 24) / 9)
		if (MON >= 0) {
			s = s sprintf("%8.8s ",cnt_name(MON))
			n--
		}
		s = s sprintf("%10.10s ",cnt_name(sec))

		for (i=0; i<COUNTERS && n>0; i++) {
			if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
				s = s sprintf("%8.8s ", cnt_name(i))
				n--
			}
		}
		printf("%s%s\n",s,Plabel)
	}
	user_postscan_head
'

#########################################################################

#########################################################################
# Used by head to save various geometry parameters
# $1 is parameter name.  $2 is #G suffix
def _head_par '
	if (whatis("$1[0]")) {
		local i
		printf("#G$2")
		for (i=0;;i++)
			if (whatis(sprintf("$1[%d]", i)))
                       printf(" %.10g", $1[i])
			else break
		printf("\n")
	}
'
#########################################################################


##########################################################################################
##########################################################################################
#  FAKE SCANS                                                                            #
##########################################################################################
##########################################################################################
global FS_MOVE
       FS_MOVE = 0
global FS_WAIT
       FS_WAIT = 0

global FS_CEN 
global FS_FWHM
global FS_AMP

##########################################################################################
def fake_dscan '{
      # 
      if (IS_TRAJ_SCAN == 1){
          eprint "Sorry fake_dscan doesnt work with traj scans yet"
          exit
      }

	if ($# != 8) {
		eprint "Usage:  fake_dscan  motor start finish  intervals time peak_amp bgr fwhm"
		exit
	} 
	_check0 "$1"
 
      # let the world know this is a fake scan
      # this is used by _loop, _head and _ascan
      IS_FAKE_SCAN = 1;  
   
      if (FS_MOVE == 1) {
         # if we are really moving the motors get the current positions 
         waitall
         get_angles
      } else {
         # otherwise update the A array, ie assume that HKL have been set
         # and now get fake values for A array
         # calcA
         # actually just use the current A assuming that HKL are already updated
         # by the caller .....
      }

 	_m[0] = $1;    
      _c1 = A[$1]
      _s[0] = _c1 + $2 
      _f[0] = _c1 + $3
	_n1 = int($4); 
      _ctime = $5
	_nm = 1

     # give vals for fake peak cen and fwhm
      FS_CEN = ( _s[0] + _f[0] ) / 2;
      FS_AMP = $6;
      FS_BGR = $7;
      FS_FWHM = $8;
      # FS_FWHM = ( _f[0] - _s[0] ) / 10;

     
      _ascan
     
     #
     IS_FAKE_SCAN = 0;

# note may have problems if cntrl-c out of a fake scan, ie this flag doesnt get reset to 0
# therefore _ascan and _head will think its a fake scan......

}'

#########################################################################
# "count" is called by the scans to count monitor or time.
# It runs the clock and reads the scalers.
def fake_scan_count '{
        local j, arg, peak_amp, bgr, pos
        # arg is either count time or number of monitor cnts
        arg = $1
        pos = A[_m[0]]

        waitmove
        for (j=0; j< COUNTERS ; j++) {
            S[j] = 0;
        }

        # below is the "peak" function
        peak_amp = FS_AMP / ( 1 + square( (pos - FS_CEN)/(FS_FWHM/2) ) );

        # calc a background 
        bgr = FS_BGR + ( sqrt(peak_amp+FS_BGR) * ( 2* (0.5 - rand(100)/100 ) ) ) ;
        if (bgr <= 0) bgr = 0; 

        #p peak_amp, bgr

        # below is the "total" function cps
        peak_amp = peak_amp + bgr;


        # lets assume io is 1e6 cps.
        # if MON = 1 using io as monitor
        # if MON = 0 or -1 using seconds as monitor
        if (MON == 1){
           S[sec] = arg/1e6;
           S[io] = arg;
           S[i1] = (0.01)*arg* ( S[sec]*peak_amp/(FS_AMP+FS_BGR) );
           S[DET] = S[sec]*peak_amp;
        } else { 
           S[sec]  = arg;
           S[io] = (arg * 1e6) ;
           S[i1] = (0.01)*( 1e6 )* (S[sec]*peak_amp/(FS_AMP+FS_BGR) ) ;
           S[DET] = S[sec]*peak_amp;
        }

        if (S[sec] && MON >= 0)
                MON_RATE=S[MON]/S[sec]

       if(FS_WAIT) sleep(S[sec])

}'

#########################################################################

#########################################################################
# fake bragg move
def fake_br '
        if ($# != 3) {
                eprint "Usage:  fake_br H K L"
                exit
        } ;
        H=$1; K=$2; L=$3
        calcA
'
#########################################################################
# fake wh
def fake_wh '
        calcHKL
        onp
        _var
        offp
'
#########################################################################
