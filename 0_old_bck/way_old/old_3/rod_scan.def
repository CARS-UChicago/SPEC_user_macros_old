### Global variable used by these macros
global RS_SCALE_BY
       RS_SCALE_BY = 1;
# RS_SCALE_BY = 0; # just use max_cnt time for all
# RS_SCALE_BY = 1; # use sqrt(1/F)
# RS_SCALE_BY = 2; # use 1/F    
global RS_CHECK_SCAN
       RS_CHECK_SCAN = 1;
global RS_SKIP_BRAGGS
       RS_SKIP_BRAGGS = 1;
global RS_MAX_REP
       RS_MAX_REP = 5;
global RS_SCAN_RANGE
       RS_SCAN_RANGE = 1;
global RS_NUM_PTS
       RS_NUM_PTS = 40;
global RS_MIN_CNT
       RS_MIN_CNT = 0.1;
global RS_I_MAX_SCALE
       RS_I_MAX_SCALE = 200; 
global RS_I_MIN_SCALE
       RS_I_MIN_SCALE = 1.1; 
global SC_ANAL_PRSD_CUTOFF
       SC_ANAL_PRSD_CUTOFF = 25;
global IS_RS
       IS_RS = 0;
global RS_TEST
       RS_TEST = 1;
global RS_PLOT_AVE
       RS_PLOT_AVE = 0;
global RS_SCAN_TITLE

# 
# Need a better rocking scan, ie stretch the bgr ??
#
# Note _ascan calls scan_data which builds the SCAN_D array...
# SCAN_D[pnt][0] = x-value
# SCAN_D[pnt][1] = sec
# SCAN_D[pnt][2] = io
#      etc.. 
# SCAN_D always(??) has all the scalars in thier usual order
# therefore, DET + 1 should also be the right col for data averaging 
# and MON + 1 to normalize the data (MON < 0 means its shut off)
# see the plotselect and counters macros 
#

# Note if doing Traj_scans should check that the fastest rocking scan
# wont exceed the limits ....

####################################################################
# Rod_scan.
def rod_scan '{
    # local vars for input data
    local h_val, k_val, l_st, l_en, del_l 
    local max_cnt, l_b, del_lb 

    # local vars for scan calcs, etc...    
    local num_l_pts, del_sign 

    # local vars for rocking scan
    local scan_range, num_scan_pts, max_cnt, max_rep, num_rep 
      scan_range    = RS_SCAN_RANGE;
      num_scan_pts  = RS_NUM_PTS;
      max_rep       = RS_MAX_REP;
      min_cnt       = RS_MIN_CNT;                   

    # other misc local vars
    local msg_str, j, exec 
    
   
    # check input
    if ($# != 9 ) {
      msg_str = "Usage: rod_scan H K L_start L_end del_L" 
      msg_str = msg_str " Scan_Axis Max_count L_bragg Delta_Lbragg\n "
      print msg_str
      exit
    } 
    # This makes sure the scan-axis exists 
    _check0 $6


    # assign input data to local vars
    h_val     = $1  
    k_val     = $2 
    l_st      = $3 
    l_en      = $4 
    del_l     = $5 
    scan_axis = $6 
    max_cnt   = $7 
    l_b       = $8 
    del_lb    = $9

    # calc num L points
    num_l_pts = int( (l_en - l_st)/del_l );
    del_sign = sign(num_l_pts);
    num_l_pts = 1 + (  del_sign * num_l_pts) ;
    if (num_l_pts <= 1) {
        msg_str = " Error: Num points = 1 "
        print msg_str
        exit
    }
    
    ## Make an array of HKL, cnt_times, F-values and bragg flags 
    #   RS_ARRAY[j][0] = H;
    #   RS_ARRAY[j][1] = K;
    #   RS_ARRAY[j][2] = L;
    #   RS_ARRAY[j][3] = count_time;
    #   RS_ARRAY[j][4] = I;
    #   RS_ARRAY[j][5] = bragg_flag;
    #
    #
    local double array RS_ARRAY[num_l_pts][6]
   {
    local l_val, bragg_flag, I 
    I_scale_max = RS_I_MAX_SCALE;  
    I_scale_min = RS_I_MIN_SCALE;
    for (j=0;j<num_l_pts;j++) {       
       bragg_flag = 0;
       RS_ARRAY[j][0] = h_val;
       RS_ARRAY[j][1] = k_val;
       RS_ARRAY[j][2] = l_val = l_st + (j)*(del_l)*(del_sign);
       RS_ARRAY[j][3] = max_cnt;
      
       I = square( sin( PI*(l_val - l_b ) / del_lb ) ); 
       if (I <= 1/I_scale_max){
             RS_ARRAY[j][4] = I_scale_max;
             RS_ARRAY[j][5] = 1;
       } else if (I >= 1/I_scale_min){
             RS_ARRAY[j][4] = I_scale_min;
             RS_ARRAY[j][5] = -1;
       } else {
             RS_ARRAY[j][4] = 1/I;
             RS_ARRAY[j][5] = 0;
       }
    }
   }

   ## Now scale the cnt times by sqrt(1/I), 1/I or just use max
   if(RS_SCALE_BY != 0){
     for (j=0;j<num_l_pts;j++) {
         if (RS_ARRAY[j][5] ==  1) {
              RS_ARRAY[j][3] = min_cnt;
         } else if (RS_ARRAY[j][5] == -1) { 
              RS_ARRAY[j][3] = max_cnt;
         } else {
              if(RS_SCALE_BY == 1){ 
                 RS_ARRAY[j][3]   = RS_ARRAY[j][3] * sqrt( 1 / RS_ARRAY[j][4] ) ;
              } else if (RS_SCALE_BY == 2){
                 RS_ARRAY[j][3]   = RS_ARRAY[j][3] * 1 / RS_ARRAY[j][4] ;
              }
         }
      }
   }

  # round the cnt times so they are even tenths of seconds ....
  # also check and make sure NO cnt_times are less than min
  {
  local temp_time, temp_rem
    for (j=0;j<num_l_pts;j++) {
         temp_time = int(RS_ARRAY[j][3]);             
         temp_rem = get_frac(RS_ARRAY[j][3]);
         temp_rem = int(10*temp_rem);
         RS_ARRAY[j][3] = temp_time + 0.1*temp_rem;
         if (RS_ARRAY[j][3] < min_cnt) RS_ARRAY[j][3] = min_cnt;
    }
  }

   ## Do pre checking on the HKL range, 
   # ie can we get to all these places
   for (j=0;j<num_l_pts;j++) {
       H = RS_ARRAY[j][0]; 
       K = RS_ARRAY[j][1]; 
       L = RS_ARRAY[j][2];
       if (calcA){
          eprintf("(H K L = %g %g %g)\n",H,K,L)
          exit
       }
       _bad_lim=0; _hkl_lim
       if (_bad_lim) {
          eprintf("(H K L = %g %g %g)\n",H,K,L)
          exit
      }
   }

# Print message that starting a new rod scan
msg_str = sprintf("%s %g %g","#ROD_SCAN rod_scan", h_val, k_val);
msg_str = sprintf("%s %g %g %g",msg_str, l_st,l_en,del_l);
msg_str = sprintf("%s %s %g %g %g", msg_str, motor_mne(scan_axis), max_cnt, l_b, del_lb); 
printf("\n%s\n", msg_str); 


## scan loop
# do the scan
# create arrays to hold the data for the scans
# the arrays should all be initialized to zero 
local double array RS_X_ARRAY[num_scan_pts+1][max_rep];
local double array RS_Y_ARRAY[num_scan_pts+1][max_rep];
local double array SCAN_INFO[max_rep][9];
local double array bad[max_rep];
local H_scan, K_scan, L_scan
######### Do the scans ##########
if (RS_CHECK_SCAN == 0) {
       # make sure the A array is updated with current values
       get_angles;    

       if (DATAFILE !=""){
           fprintf(DATAFILE,"\n%s\n", msg_str); 
       }
       
       ####### start L loop ############# 
       for (j=0;j<num_l_pts;j++) {
           # clear data arrays
           RS_X_ARRAY = 0;
           RS_Y_ARRAY = 0;
           SCAN_INFO = 0;
           bad = 0;

           # get HKL and cnt time for the scan
           H_scan = RS_ARRAY[j][0]; 
           K_scan = RS_ARRAY[j][1]; 
           L_scan = RS_ARRAY[j][2];


           ## if its a bragg skip it
           if ( (RS_ARRAY[j][5] == 1) && (RS_SKIP_BRAGGS == 1) ) {
              printf("%s\n",RS_SCAN_TITLE);
              msg_str = sprintf("#Skip L = %g, Bragg Peak", L_scan);
              printf("%s\n",msg_str);
           } else {
           ## do the scan
              local st, en, n, ti;
              st =  -1*scan_range/2;
              en = scan_range/2;
              np = num_scan_pts;
              ti = RS_ARRAY[j][3];

              ### keep doing the scan untill its good enough or hit max repeat ...
              num_rep = 0; exec = 1;
              while( (exec==1) && (num_rep<max_rep) ) { 
                    RS_SCAN_TITLE = sprintf("#RS H = %g , K = %g , L = %g, num = %d", \
                                             H_scan,K_scan,L_scan, num_rep + 1);
                    printf("%s\n",RS_SCAN_TITLE);

                   if (RS_TEST) {
                      fake_br H_scan K_scan L_scan 
                      waitmove
                      fake_dscan $6 st en np ti 10*RS_ARRAY[j][4] 10 .1
                   # or do the real scan
                   } else {
                      br H_scan K_scan L_scan 
                      waitmove
                      dscan $6 st en np ti  
                   }
 
                   # load the data from this scan into an array for averaging
                   # and analyzing ......
                   RS_X_ARRAY[0:np][num_rep] = SCAN_D[0:np][0];
                   if(MON < 0){
                      RS_Y_ARRAY[0:np][num_rep] = SCAN_D[0:np][DET+1];
                   } else {
                      RS_Y_ARRAY[0:np][num_rep] = SCAN_D[0:np][DET+1]/SCAN_D[0:np][MON+1];
                   }

                   # check the data
                   # SCAN_INFO[num_rep][] = SC_ANAL(RS_X_ARRAY, RS_Y_ARRAY, num_rep + 1, bad ); 
                   # bad[num_rep] = SCAN_INFO[num_rep][0];
                   
                   # redo with globals 
                   bad[num_rep] = SC_ANAL(RS_X_ARRAY, RS_Y_ARRAY, num_rep + 1, bad );

                   SCAN_INFO[num_rep][0] = SC_ANAL_BAD         # = summary_data[0][0];
                   SCAN_INFO[num_rep][1] = SC_ANAL_Y_MAX       # = summary_data[0][1];
                   SCAN_INFO[num_rep][2] = SC_ANAL_X_AT_Y_MAX  # = summary_data[0][2];
                   SCAN_INFO[num_rep][3] = SC_ANAL_FWHM        # = summary_data[0][3];
                   SCAN_INFO[num_rep][4] = SC_ANAL_CFWHM       # = summary_data[0][4];
                   SCAN_INFO[num_rep][5] = SC_ANAL_LHMX        # = summary_data[0][5];
                   SCAN_INFO[num_rep][6] = SC_ANAL_UHMX        # = summary_data[0][6];
                   SCAN_INFO[num_rep][7] = SC_ANAL_I           # = summary_data[0][7];
                   SCAN_INFO[num_rep][8] = SC_ANAL_PRSD        # = summary_data[0][8];

                   # p SCAN_INFO
                   # if its ok move on
                   if (bad[num_rep] == 0) exec = 0;

                   # here need to print some info about the scan 
                   # ie at leat have to print the value of BAD_SCAN_IDX .....
                   num_rep = num_rep + 1;
                   
              }  
             #### end of while loop on the scan
             # here need to print some info about the avg scan?? .....
           }
       }
       ######### end L loop#########
########## check the scan #############
} else {
       # check out the scan info
       local tot_time;
       tot_time = 0;
       p "test scan info"
       p "       H      K      L     cnt      I      b_flag "
       for (j=0;j<num_l_pts;j++){
           msg_str="";        
           for(k=0;k<6;k++){
            msg_str = sprintf("%s  %6.5g", msg_str, RS_ARRAY[j][k]);
           }
           tot_time = tot_time + RS_ARRAY[j][3]*num_scan_pts;
           msg_str = sprintf("%s \n", msg_str);
           p msg_str;
       }      
       p "Number of points = ", num_l_pts
       p "Estimated total time (sec) = ", tot_time 
       p "Estimated total time (min) = ", tot_time / 60 
       p "Estimated total time (hrs) = ", tot_time / 3600 
      
}
####### end of scan loop

# may want to print a message that its done
# note what happens if cntrl-c outa the scan?

}'

###################################################################################
#  end of rod_scan
#
# Below are analysis and plotting macros
###################################################################################
# Analysis and plotting macros
# define and use these globals bc getting random crashes when 
# trying to get SC_ANAL to return summary_data_array directly ...
# these are for the SC_ANAL macro
global SC_ANAL_BAD         # = summary_data_array[0][0];
global SC_ANAL_Y_MAX       # = summary_data_array[0][1];
global SC_ANAL_X_AT_Y_MAX  # = summary_data_array[0][2];
global SC_ANAL_FWHM        # = summary_data_array[0][3];
global SC_ANAL_CFWHM       # = summary_data_array[0][4];
global SC_ANAL_LHMX        # = summary_data_array[0][5];
global SC_ANAL_UHMX        # = summary_data_array[0][6];
global SC_ANAL_I           # = summary_data_array[0][7];
global SC_ANAL_PRSD        # = summary_data_array[0][8];

# these are for the RS_INT macro
global SC_INT_I
global SC_INT_Itot
global SC_INT_BGR
global SC_INT_PRSD

###################################################################################
# analyze the scan data
# initially wanted this macro to return summary_data_array directly
# this seems to cause crashes, therefore have it fill in a bunch of globals
#
# now this function returns just a scalar which is
# the same value as SC_ANAL_BAD
# SC_ANAL_BAD =  0   is a good scan (or avg is good)
# SC_ANAL_BAD =  1   poor stats repeat same scan and avg
# SC_ANAL_BAD =  2   detector is saturated, repeat and dont avg
# SC_ANAL_BAD =  3   scan is too narrow, repeat wider (? include in average)
# SC_ANAL_BAD =  4   scan is too wide, repeat narrower (? include in average)
# SC_ANAL_BAD =  5   problem calculating the stats ... dont avg(??)
###################################################################################

def SC_ANAL( rs_x_array, rs_y_array, rs_nscans, bad_idx_array) '{
        local j, rs_nrows, rs_ncols, n_ave, idx, test; 
       
        # declare array and initialize to all zeros
        local double array summary_data_array[1][9];

        # init all the globals to zero as well
        SC_ANAL_BAD          = summary_data_array[0][0] = 0;
        SC_ANAL_Y_MAX        = summary_data_array[0][1] = 0;
        SC_ANAL_X_AT_Y_MAX   = summary_data_array[0][2] = 0;
        SC_ANAL_FWHM         = summary_data_array[0][3] = 0;
        SC_ANAL_CFWHM        = summary_data_array[0][4] = 0;
        SC_ANAL_LHMX         = summary_data_array[0][5] = 0;
        SC_ANAL_UHMX         = summary_data_array[0][6] = 0;
        SC_ANAL_I            = summary_data_array[0][7] = 0;
        SC_ANAL_PRSD         = summary_data_array[0][8] = 0;


         
        rs_nrows = array_op("rows",rs_x_array);
        if( rs_nrows != array_op("rows",rs_y_array) ) {
            print "Error array mismatch"
            SC_ANAL_BAD = summary_data_array[0][0] = 5.0;
            return(5);
        }

        rs_ncols = array_op("cols",rs_x_array);
        if( rs_ncols != array_op("cols",rs_y_array) ) {
            print "Error array mismatch"
            SC_ANAL_BAD = summary_data_array[0][0] = 5.0;
            return(5);
        }

        # check for saturation
        test = CHECK_SAT();
        if( test > 0) {
            SC_ANAL_BAD = summary_data_array[0][0] = 2;
            return(2);
        } 

        # check for width vs range ???
        # return 3 or 4
        # here may want to avg the data but will have to 
        # interpolate the data ......
        # note if the number of points in the scan changes then 
        # the data array is all screwed up .....
        # how do you do interpolations for traj scan data ?????


        # average the good data
        # note should do an interpolation then ave ???
        local double array AVG_ARRAY[rs_nrows][2];
        AVG_ARRAY = 0.0;
        n_ave = 0;
        for (j=0;j<rs_nscans;j++){
           # note the bad_scan array was initialized to zeros
           # therefore this will include the newest data if the above
           # tests were passed
           if (bad_idx_array[j] < 2){
               AVG_ARRAY[][0] = AVG_ARRAY[][0] + rs_x_array[][j] ;  # x ave
               AVG_ARRAY[][1] = AVG_ARRAY[][1] + rs_y_array[][j] ;  # y ave
               n_ave = n_ave + 1;
           }
        }

        
        # this should never happen
        if (n_ave ==0){
            SC_ANAL_BAD = summary_data_array[0][0] = 5.0;
            return (5);  
        }
        AVG_ARRAY[][0] = AVG_ARRAY[][0] / n_ave;   # x ave
        AVG_ARRAY[][1] = AVG_ARRAY[][1] / n_ave;   # y ave

#p AVG_ARRAY
#p "ave array rows = " array_op("rows",AVG_ARRAY)
#p "ave array cols = " array_op("cols",AVG_ARRAY)


        # now get some data
        idx = array_op("rmax",AVG_ARRAY[][1]);
        summary_data_array[0][1] = AVG_ARRAY[idx][1];
        summary_data_array[0][2] = AVG_ARRAY[idx][0];
        summary_data_array[0][3] = array_op("fwhm",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][4] = array_op("cfwhm",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][5] = array_op("lhmx",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][6] = array_op("uhmx",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        test = SC_INT( AVG_ARRAY, 5);
        if (test == 1){
          summary_data_array[0][7] = SC_INT_I;
          summary_data_array[0][8] = SC_INT_PRSD;
        } else {
          summary_data_array[0][7] = 0 ;
          summary_data_array[0][8] = 0 ;
        }


        if(RS_PLOT_AVE){
           # initialize the plot and plot the avg data
           RS_INIT_PLOT( n_ave, summary_data_array ) 
           array_plot(AVG_ARRAY[][0],AVG_ARRAY[][1])
        
           p "Plotted avg data for nscans = ", n_ave  
           xx = getval("hit any key to cont");
        }

# this seems to work but getting random crashes when return this array data
# return(summary_data_array);

SC_ANAL_Y_MAX        = summary_data_array[0][1];
SC_ANAL_X_AT_Y_MAX   = summary_data_array[0][2];
SC_ANAL_FWHM         = summary_data_array[0][3];
SC_ANAL_CFWHM        = summary_data_array[0][4];
SC_ANAL_LHMX         = summary_data_array[0][5];
SC_ANAL_UHMX         = summary_data_array[0][6];
SC_ANAL_I            = summary_data_array[0][7];
SC_ANAL_PRSD         = summary_data_array[0][8];

if ( (SC_ANAL_PRSD < SC_ANAL_PRSD_CUTOFF) && (SC_ANAL_I > 0) ){
    SC_ANAL_BAD = summary_data_array[0][0] = 0;
} else {
    SC_ANAL_BAD = summary_data_array[0][0] = 1;      
}

return(SC_ANAL_BAD);

}'


####################################################################
# Integrate the data ....
# note assume that sig2_y = Y is error of the signal 
# and its prop to the sqrt of det cnts
####################################################################
def SC_INT(DAT, num_bgr) '{
    local j 
    local nrow, ncol; 
       nrow = ncol = 0;
    local idx_low, idx_high;
       idx_low = idx_high = 0;
    local idx_sl, idx_sh;
       idx_sl =  idx_sh = 0;
    local bgr_l, bgr_h, bgr_err
       bgr_l = bgr_h = bgr_err = 0;
    local int_idx, del_x_tot, Itot, sig2_I
       int_idx = del_x_tot = Itot = sig2_I = 0;
    local del_x_ave, ave_bgr, bgr;
       ave_bgr = bgr = 0;
    local I, sig
       I = sig = 0;

    if (num_bgr == 0) num_bgr = 5;
    RS_INT_I = 0;
    RS_INT_Itot = 0;
    RS_INT_BGR = 0;
    RS_INT_PRSD = 0;


    # check the data array
    nrow = array_op("rows",DAT);
    ncol = array_op("cols",DAT);

    if( (nrow < 2) || (ncol!=2) ) {
         print "Array wrong needs to be nrows x 2 cols"
         return(1);
    }
   
    # get the high and low indecies
    # always throw away the first point
    # ie get del_x by 2nd - 1st
    idx_low = 1;    
    idx_high = nrow-1; 

   # index for signal points low side and high side
   idx_sl =  idx_low + num_bgr - 1; 
   idx_sh =  idx_high - (num_bgr - 1);

   # get the bgr on the low side, then high side
   for (j = idx_low; j <= idx_sl; j++){
      bgr_l = bgr_l + DAT[j][1] / fabs( DAT[j][0] - DAT[j-1][0] );    # makes cnts/del_x 
      bgr_err = bgr_err + DAT[j][1]; 
   }
   for (j =  idx_sh; j <= idx_high; j++){ 
      bgr_h = bgr_h + DAT[j][1] / fabs( DAT[j][0] - DAT[j-1][0] );    # makes cnt/del_x
      bgr_err = bgr_err + DAT[j][1];
   }

  # get the total integrated intensity
  # for (j = idx_sl; j<idx_sh; j++){  
  for (j = idx_low; j <= idx_high; j++){ 
    int_idx = int_idx + 1;
    del_x_tot = del_x_tot + fabs( DAT[j][0] - DAT[j-1][0] );   
    Itot = Itot + DAT[j][1];              
    sig2_I = sig2_I + DAT[j][1];  
  }

  # get the tot bgr
  ave_bgr = (bgr_h + bgr_l)/(2*num_bgr);
  bgr = ave_bgr* del_x_tot;

 
  # get the bgr subtracted intensity and err
  I = Itot - bgr;
  sig=sqrt( sig2_I + bgr_err * ( square( del_x_tot/(2*num_bgr) )  ) );
  if (I < 0) I = 0; 


 # return stuff
  SC_INT_I = I;
  SC_INT_Itot = Itot;
  SC_INT_BGR = bgr;
  if(I>0){
     SC_INT_PRSD = 100*sqrt(sig2_I)/I;
  } else {
     SC_INT_PRSD = 0;
  }

p  "Itot = " SC_INT_Itot, ", bgr = "  SC_INT_BGR, ", I = " SC_INT_I, ", prsd =" SC_INT_PRSD 
p  "Ave_bgr = " bgr/int_idx ", Bgr = " bgr  ", Tot x = " del_x_tot
return(1);

}'
####################################################################


####################################################################
# Initialize the plot
# this is similiar to the splot macro in standard.mac
####################################################################
def RS_INIT_PLOT( nscans, summary_data ) '{
        local title, y_label, plot_str 

        # set up the plot window to plot the averaged data
        if (PLOT_MODE&128) {
		plot_cntl(sprintf("colors=%s",splot_col))
		plot_cntl("open")
	  }
	  plot_cntl("erase")
	  plot_cntl(PLOT_MODE&8? "xexact":"-xexact")
	  plot_cntl(PLOT_MODE&32? "ylog":"-ylog")
	  plot_cntl(PLOT_MODE&256? "-dots":"dots")
	  plot_cntl(PLOT_MODE&512? "-lines":"lines")
	  plot_cntl(PLOT_MODE&1024? "-ebars":"ebars")

        # plot range
	  plot_range("auto","auto","auto","auto")

        # title, y-axis label, x-axis label
        plot_str = sprintf("%s, nave = %d, last scan = %d", RS_SCAN_TITLE,nscans, SCAN_N);
        printf("%s\n",plot_str);
	  plot_move(15,0,plot_str)

        plot_str = sprintf("Ave(%s/%s)", cnt_mne(DET), cnt_mne(MON));
	  plot_move(0,0,plot_str)

	  plot_move(0,-1,sprintf("%.8s", pl_xl))

        plot_str = sprintf("Y_max = %g, X at Y_max = %g, fwhm = %g, cfwhm = %g", \
                            summary_data[0][1], summary_data[0][2], \
                            summary_data[0][3], summary_data[0][4]) 
        printf("%s\n",plot_str);
	  plot_move(10,1,plot_str);

        plot_str = sprintf("lhmx = %g, uhmx = %g, I = %g, prsd = %g", \
                             summary_data[0][5], summary_data[0][6], \
                             summary_data[0][7], summary_data[0][8]); 
        printf("%s\n",plot_str);
	  plot_move(10,2,plot_str);

        #plot_move(0,3)

}'
####################################################################





