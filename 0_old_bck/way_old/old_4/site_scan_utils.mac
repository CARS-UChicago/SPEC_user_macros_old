##########################################################################################
##########################################################################################
#  Simple utilities                                                                      #
##########################################################################################
##########################################################################################

############################################################################
# macro to return the sign of a number
def sign(x) '{ 
    if (x < 0) {
       return(-1)
    } else if (x > 0) { 
       return(1)
    } else { 
      return(0)
    }      
}'
############################################################################

############################################################################
# macro to return the square of a number
def square(x) '{ 
      return(x*x)      
}'
############################################################################

############################################################################
# macro to return the fraction part of a real number
def get_frac(x) '{ 
      x = fabs(x);
      if ( x < 1 ) {
         return(x);
      } else {
         return(  x - int(x)  )   
      }   
}'
############################################################################


##########################################################################################
##########################################################################################
#  Attenuators                                                                           #
##########################################################################################
##########################################################################################
# ToDO
# - make a macro to set these globals and determine atten factors!!!
# - make more complete, ie based on atten factors calc the best combo of filters.....
##########################################################################################
# globals for attenuator macros macro
##########################################################################################
array  ATTEN[4]
       ATTEN = 0;
global SAT_CNTR_IDX
       SAT_CNTR_IDX = 2;   # i1

# cps in i1 when bicron is sat ....
array SAT_CNTR_VAL[4]
       SAT_CNTR_VAL[0] = 1e5;  # add atten 1  
       SAT_CNTR_VAL[1] = 5e5;  # add atten 2
       SAT_CNTR_VAL[2] = 1e6;  # add atten 3
       SAT_CNTR_VAL[3] = 5e6;  # add atten 4

##########################################################################################
# Check saturation
# note if do_set = 1 this will force the
# update of the attenuators
# otherwise this macro will only call add_atten if
# it thinks it needs to.
#
def CHECK_SAT(do_set) '{

   # note NPTS is set in the _ascan macro
   local num_rows, j
   num_rows = NPTS;

   local array sat_mon_array[num_rows][1];
   local sat_cnts, sat;
   local array atten_level[4];
               atten_level = 0;

   ## look at cps in i1
   sat_mon_array[][0] = SCAN_D[0:num_rows-1][SAT_CNTR_IDX+1]/SCAN_D[0:num_rows-1][sec+1];
   sat_cnts = array_op("max", sat_mon_array[][0]);
   # p "Sat cnt = " sat_cnts
 
 if( sat_cnts  < SAT_CNTR_VAL[0] ) atten_level = 0;
 if( sat_cnts >= SAT_CNTR_VAL[0] ) atten_level[0] = 1;
 if( sat_cnts >= SAT_CNTR_VAL[1] ) atten_level[1] = 1;
 if( sat_cnts >= SAT_CNTR_VAL[2] ) atten_level[2] = 1;
 if( sat_cnts >= SAT_CNTR_VAL[3] ) atten_level[3] = 1;

 sat = 0;
 for(j=1;j<4;j++){
     if (atten_level[j] != ATTEN[j] ){
         sat = 1;
     }
 }

if (sat == 1 || do_set == 1) { 
  add_atten( atten_level[0], atten_level[1], atten_level[2], atten_level[3] ); 
  p "Updating Attenuators"
}
return(sat);

}'

##########################################################################################
## add attenuators for detector arm
def add_atten(set1, set2, set3, set4) '{   
 
 if ( set1 == 1  ){
     epics_put("13IDC:UnidigBo17.VAL",0)
 } else {
     epics_put("13IDC:UnidigBo17.VAL",1)
 }

 if ( set2 == 1  ){
     epics_put("13IDC:UnidigBo19.VAL",0)
 } else {
     epics_put("13IDC:UnidigBo19.VAL",1)
 }

 if ( set3 == 1  ){
     epics_put("13IDC:UnidigBo21.VAL",0)
 } else {
     epics_put("13IDC:UnidigBo21.VAL",1)
 }

 if ( set4 == 1  ){
     epics_put("13IDC:UnidigBo23.VAL",0)
 } else {
     epics_put("13IDC:UnidigBo23.VAL",1)
 }


# test
#p epics_get("13IDC:UnidigBi17.VAL")
#p epics_get("13IDC:UnidigBi19.VAL")
#p epics_get("13IDC:UnidigBi21.VAL")
#p epics_get("13IDC:UnidigBi23.VAL")
#p " "

sleep(1);

# check status of attenators
# note Low = 0 = "attenuator in" in the epics pv
# but were saying that if ATTEN[i] = 0 the atten is out
ATTEN = 0;
if( epics_get("13IDC:UnidigBi16.VAL") == "Low") ATTEN[0]=1;
if( epics_get("13IDC:UnidigBi18.VAL") == "Low") ATTEN[1]=1;
if( epics_get("13IDC:UnidigBi20.VAL") == "Low") ATTEN[2]=1;
if( epics_get("13IDC:UnidigBi22.VAL") == "Low") ATTEN[3]=1;

}'
############################################################################



##########################################################################################
##########################################################################################
#  FAKE SCANS                                                                            #
##########################################################################################
##########################################################################################
# Globals
global FS_MOVE
       FS_MOVE = 0
global FS_WAIT
       FS_WAIT = 0

global FS_CEN 
global FS_FWHM
global FS_AMP

##########################################################################################
# a fake dscan
def fake_dscan '{
      # 
      if (IS_TRAJ_SCAN == 1){
          eprint "Sorry fake_dscan doesnt work with traj scans yet"
          exit
      }

	if ($# != 8) {
		eprint "Usage:  fake_dscan  motor start finish  intervals time peak_amp bgr fwhm"
		exit
	} 
	_check0 "$1"
 
      # let the world know this is a fake scan
      # this is used by _loop, _head and _ascan
      IS_FAKE_SCAN = 1;  
   
      if (FS_MOVE == 1) {
         # if we are really moving the motors get the current positions 
         waitall
         get_angles
      } else {
         # otherwise update the A array, ie assume that HKL have been set
         # and now get fake values for A array
         # calcA
         # actually just use the current A assuming that HKL are already updated
         # by the caller .....
      }

 	_m[0] = $1;    
      _c1 = A[$1]
      _s[0] = _c1 + $2 
      _f[0] = _c1 + $3
	_n1 = int($4); 
      _ctime = $5
	_nm = 1

     # give vals for fake peak cen and fwhm
      FS_CEN = ( _s[0] + _f[0] ) / 2;
      FS_AMP = $6;
      FS_BGR = $7;
      FS_FWHM = $8;
      # FS_FWHM = ( _f[0] - _s[0] ) / 10;

     
      _ascan
   
     # reset stuff after scan
     fake_dscan_cleanup;

}'

##########################################################################################
# a fake dscan
# call at the end of a fake_dscan or when cntrl-c is hit (see the gse_cleanup macro)
def fake_dscan_cleanup '{
        IS_FAKE_SCAN = FALSE;
        # FS_WAIT      = FALSE;
        # FS_MOVE      = FASLE;
}'

#########################################################################
# "count" is called by the scans to count monitor or time.
# It runs the clock and reads the scalers.
def fake_scan_count '{
        local j, arg, peak_amp, bgr, pos
        # arg is either count time or number of monitor cnts
        arg = $1
        pos = A[_m[0]]

        waitmove
        for (j=0; j< COUNTERS ; j++) {
            S[j] = 0;
        }

        # below is the "peak" function
        peak_amp = FS_AMP / ( 1 + square( (pos - FS_CEN)/(FS_FWHM/2) ) );

        # calc a background 
        bgr = FS_BGR + ( sqrt(peak_amp+FS_BGR) * ( 2* (0.5 - rand(100)/100 ) ) ) ;
        if (bgr <= 0) bgr = 0; 

        #p peak_amp, bgr

        # below is the "total" function cps
        peak_amp = peak_amp + bgr;


        # lets assume io is 1e6 cps.
        # if MON = 1 using io as monitor
        # if MON = 0 or -1 using seconds as monitor
        if (MON == 1){
           S[sec] = arg/1e6;
           S[io] = arg;
           S[i1] = (0.01)*arg* ( S[sec]*peak_amp/(FS_AMP+FS_BGR) );
           S[DET] = S[sec]*peak_amp;
        } else { 
           S[sec]  = arg;
           S[io] = (arg * 1e6) ;
           S[i1] = (0.01)*( 1e6 )* (S[sec]*peak_amp/(FS_AMP+FS_BGR) ) ;
           S[DET] = S[sec]*peak_amp;
        }

        if (S[sec] && MON >= 0)
                MON_RATE=S[MON]/S[sec]

       if(FS_WAIT) sleep(S[sec])

}'

#########################################################################

#########################################################################
# fake bragg move
def fake_br '
        if ($# != 3) {
                eprint "Usage:  fake_br H K L"
                exit
        } ;
        H=$1; K=$2; L=$3
        calcA
'
#########################################################################
# fake wh
def fake_wh '
        calcHKL
        onp
        _var
        offp
'
#########################################################################

