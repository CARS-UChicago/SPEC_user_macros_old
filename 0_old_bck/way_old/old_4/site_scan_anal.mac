
##########################################################################################
##########################################################################################
#  Data Analysis                                                                         #
##########################################################################################
##########################################################################################
# ToDo
# - add integration option for point scans?
# - make a macro for checking scan range vs peak width
# - option for interpolating in data averaging
###################################################################################
# Analysis and plotting macros
# define and use these globals bc getting random crashes when 
# trying to get SC_ANAL to return summary_data_array directly ...
# these are for the SC_ANAL macro
global SC_ANAL_BAD               # = summary_data_array[0][0];
global SC_ANAL_Y_MAX             # = summary_data_array[0][1];
global SC_ANAL_X_AT_Y_MAX        # = summary_data_array[0][2];
global SC_ANAL_FWHM              # = summary_data_array[0][3];
global SC_ANAL_CFWHM             # = summary_data_array[0][4];
global SC_ANAL_LHMX              # = summary_data_array[0][5];
global SC_ANAL_UHMX              # = summary_data_array[0][6];
global SC_ANAL_I                 # = summary_data_array[0][7];
global SC_ANAL_PRSD              # = summary_data_array[0][8];

# define PRSD cuttoff for stats
global SC_ANAL_PRSD_CUTOFF
       SC_ANAL_PRSD_CUTOFF = 25;

# do we want plots of avg data
global SC_PLOT_AVE
       SC_PLOT_AVE = TRUE;
global SC_PLOT_PAUSE
       SC_PLOT_PAUSE = FALSE;

# these are for the SC_INT macro
global SC_INT_I
global SC_INT_Itot
global SC_INT_BGR
global SC_INT_AVE_BGR
global SC_INT_PRSD


###################################################################################
# analyze the scan data
# initially wanted this macro to return summary_data_array directly
# this seems to cause crashes, therefore have it fill in a bunch of globals
#
# now this function returns just a scalar which is
# the same value as SC_ANAL_BAD
# SC_ANAL_BAD =  0   is a good scan (or avg is good)
# SC_ANAL_BAD =  1   poor stats repeat same scan and avg
# SC_ANAL_BAD =  2   detector is saturated, repeat and dont avg
# SC_ANAL_BAD =  3   scan is too narrow, repeat wider (? include in average)
# SC_ANAL_BAD =  4   scan is too wide, repeat narrower (? include in average)
# SC_ANAL_BAD =  5   problem calculating the stats ... dont avg(??)
###################################################################################
# Not this function wants an array of x and y values
# the arrays should have scan points as rows and each col = a different scan
# x and y dims must match
# nscans is the index for the number to avg over
# bad is an array indicating if the scan should be included in the avg
#
def SC_ANAL( sc_x_array, sc_y_array, sc_nscans, bad_idx_array) '{
        local j, sc_nrows, sc_ncols, n_ave, idx, test; 
       
        # declare array and initialize to all zeros
        local double array summary_data_array[1][12];

        # init all the globals to zero as well
        SC_ANAL_BAD          = summary_data_array[0][0] = 0;
        SC_ANAL_Y_MAX        = summary_data_array[0][1] = 0;
        SC_ANAL_X_AT_Y_MAX   = summary_data_array[0][2] = 0;
        SC_ANAL_FWHM         = summary_data_array[0][3] = 0;
        SC_ANAL_CFWHM        = summary_data_array[0][4] = 0;
        SC_ANAL_LHMX         = summary_data_array[0][5] = 0;
        SC_ANAL_UHMX         = summary_data_array[0][6] = 0;
        SC_ANAL_I            = summary_data_array[0][7] = 0;
        SC_ANAL_PRSD         = summary_data_array[0][8] = 0;
        SC_ANAL_Itot         = summary_data_array[0][9]  = 0;
        SC_ANAL_BGR          = summary_data_array[0][10]  = 0;
        SC_ANAL_AVE_BGR      = summary_data_array[0][11]  = 0;


         
        sc_nrows = array_op("rows",sc_x_array);
        if( sc_nrows != array_op("rows",sc_y_array) ) {
            print "Error array mismatch"
            SC_ANAL_BAD = summary_data_array[0][0] = 5.0;
            return(5);
        }

        sc_ncols = array_op("cols",sc_x_array);
        if( sc_ncols != array_op("cols",sc_y_array) ) {
            print "Error array mismatch"
            SC_ANAL_BAD = summary_data_array[0][0] = 5.0;
            return(5);
        }

        # check for saturation
        test = CHECK_SAT();
        if( test > 0) {
            SC_ANAL_BAD = summary_data_array[0][0] = 2;
            return(2);
        } 

        # check for width vs range ???
        # return 3 or 4
        # here may want to avg the data but will have to 
        # interpolate the data ......
        # note if the number of points in the scan changes then 
        # the data array is all screwed up .....
        # how do you do interpolations for traj scan data ?????


        # average the good data
        # note should do an interpolation then ave ???
        local double array AVG_ARRAY[sc_nrows][2];
        AVG_ARRAY = 0.0;
        n_ave = 0;
        for (j=0;j<sc_nscans;j++){
           # note the bad_scan array should be initialized to zeros
           # therefore this will include the newest data if the above
           # tests were passed
           if (bad_idx_array[j] < 2){
               AVG_ARRAY[][0] = AVG_ARRAY[][0] + sc_x_array[][j] ;  # x ave
               AVG_ARRAY[][1] = AVG_ARRAY[][1] + sc_y_array[][j] ;  # y ave
               n_ave = n_ave + 1;
           }
        }

        
        # this should never happen
        if (n_ave ==0){
            SC_ANAL_BAD = summary_data_array[0][0] = 5.0;
            return (5);  
        }
        AVG_ARRAY[][0] = AVG_ARRAY[][0] / n_ave;   # x ave
        AVG_ARRAY[][1] = AVG_ARRAY[][1] / n_ave;   # y ave

        # now get some data
        idx = array_op("rmax",AVG_ARRAY[][1]);
        summary_data_array[0][1] = AVG_ARRAY[idx][1];
        summary_data_array[0][2] = AVG_ARRAY[idx][0];
        summary_data_array[0][3] = array_op("fwhm",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][4] = array_op("cfwhm",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][5] = array_op("lhmx",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][6] = array_op("uhmx",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        test = SC_INT( AVG_ARRAY, 5);
        if (test == 1){                           # int ok
          summary_data_array[0][7] = SC_INT_I;
          summary_data_array[0][8] = SC_INT_PRSD;
          summary_data_array[0][9] = SC_INT_Itot;
          summary_data_array[0][10] = SC_INT_BGR;
          summary_data_array[0][11] = SC_INT_AVE_BGR;
         } else {                                  # int failed
          summary_data_array[0][7] = 0;
          summary_data_array[0][8] = 0;
          summary_data_array[0][9] = 0;
          summary_data_array[0][10] = 0;
          summary_data_array[0][11] = 0;
         SC_ANAL_BAD = summary_data_array[0][0] = 5.0;
        }

        if ( (summary_data_array[0][8] < SC_ANAL_PRSD_CUTOFF) && (summary_data_array[0][7] > 0) ) {
            SC_ANAL_BAD = summary_data_array[0][0] = 0;
        } else if ( summary_data_array[0][0] != 5) {
            SC_ANAL_BAD = summary_data_array[0][0] = 1;      
        }

        if(SC_PLOT_AVE){
           local xx
           # initialize the plot and plot the avg data
           RS_INIT_PLOT( n_ave, summary_data_array ) 
           array_plot(AVG_ARRAY[][0],AVG_ARRAY[][1]) 
           if ( SC_PLOT_PAUSE ){ 
               xx = getval("In SC_PLOT_PAUSE mode, hit any key to cont","y");
           }
        }

# this seems to work but getting random crashes when return this array data
# return(summary_data_array);
# instead make everything a global and just send back SC_ANAL_BAD

SC_ANAL_Y_MAX        = summary_data_array[0][1];
SC_ANAL_X_AT_Y_MAX   = summary_data_array[0][2];
SC_ANAL_FWHM         = summary_data_array[0][3];
SC_ANAL_CFWHM        = summary_data_array[0][4];
SC_ANAL_LHMX         = summary_data_array[0][5];
SC_ANAL_UHMX         = summary_data_array[0][6];
SC_ANAL_I            = summary_data_array[0][7];
SC_ANAL_PRSD         = summary_data_array[0][8];
SC_ANAL_Itot         = summary_data_array[0][9];
SC_ANAL_BGR          = summary_data_array[0][10];
SC_ANAL_AVE_BGR      = summary_data_array[0][11];

return(SC_ANAL_BAD);

}'

####################################################################


# maro to check for width vs range ...


####################################################################
# Integrate the data ....
# note assume that sig2_y = Y is error of the signal 
# and its prop to the sqrt of det cnts
# DAT should be a col of x and a col of Y data
# note this is a histogram int --> correct for traj scans!
####################################################################
def SC_INT(DAT, num_bgr) '{
    local j 
    local nrow, ncol; 
       nrow = ncol = 0;
    local idx_low, idx_high;
       idx_low = idx_high = 0;
    local idx_sl, idx_sh;
       idx_sl =  idx_sh = 0;
    local bgr_l, bgr_h, bgr_err
       bgr_l = bgr_h = bgr_err = 0;
    local int_idx, del_x_tot, Itot, sig2_I
       int_idx = del_x_tot = Itot = sig2_I = 0;
    local del_x_ave, ave_bgr, bgr;
       ave_bgr = bgr = 0;
    local I, sig
       I = sig = 0;

    if (num_bgr == 0) num_bgr = 5;
    RS_INT_I = 0;
    RS_INT_Itot = 0;
    RS_INT_BGR = 0;
    SC_INT_AVE_BGR = 0;
    RS_INT_PRSD = 0;


    # check the data array
    nrow = array_op("rows",DAT);
    ncol = array_op("cols",DAT);

    if( (nrow < 2) || (ncol!=2) ) {
         print "Array wrong needs to be nrows x 2 cols"
         return(1);
    }
   
    # get the high and low indecies
    # always throw away the first point
    # ie get del_x by 2nd - 1st
    idx_low = 1;    
    idx_high = nrow-1; 

   # index for signal points low side and high side
   idx_sl =  idx_low + num_bgr - 1; 
   idx_sh =  idx_high - (num_bgr - 1);

   # get the bgr on the low side, then high side
   for (j = idx_low; j <= idx_sl; j++){
      bgr_l = bgr_l + DAT[j][1] / fabs( DAT[j][0] - DAT[j-1][0] );    # makes cnts/del_x 
      bgr_err = bgr_err + DAT[j][1]; 
   }
   for (j =  idx_sh; j <= idx_high; j++){ 
      bgr_h = bgr_h + DAT[j][1] / fabs( DAT[j][0] - DAT[j-1][0] );    # makes cnt/del_x
      bgr_err = bgr_err + DAT[j][1];
   }

  # get the total integrated intensity
  # for (j = idx_sl; j<idx_sh; j++){  
  for (j = idx_low; j <= idx_high; j++){ 
    int_idx = int_idx + 1;
    del_x_tot = del_x_tot + fabs( DAT[j][0] - DAT[j-1][0] );   
    Itot = Itot + DAT[j][1];              
    sig2_I = sig2_I + DAT[j][1];  
  }

  # get the tot bgr
  ave_bgr = (bgr_h + bgr_l)/(2*num_bgr);
  bgr = ave_bgr* del_x_tot;

 
  # get the bgr subtracted intensity and err
  I = Itot - bgr;
  sig=sqrt( sig2_I + bgr_err * ( square( del_x_tot/(2*num_bgr) )  ) );
  if (I < 0) I = 0; 


 # return stuff
  SC_INT_I = I;
  SC_INT_Itot = Itot;
  SC_INT_BGR = bgr;
  SC_INT_AVE_BGR = bgr/int_idx;
  if(I>0){
     SC_INT_PRSD = 100*sqrt(sig2_I)/I;
  } else {
     SC_INT_PRSD = 0;
  }

return(1);

}'
####################################################################


####################################################################
# Initialize the plot for SC_ANAL
# this is similiar to the splot macro in standard.mac
####################################################################
def RS_INIT_PLOT( nscans, summary_data ) '{
        local title, y_label, plot_str 

        # set up the plot window to plot the averaged data
        if (PLOT_MODE&128) {
		plot_cntl(sprintf("colors=%s",splot_col))
		plot_cntl("open")
	  }
	  plot_cntl("erase")
	  plot_cntl(PLOT_MODE&8? "xexact":"-xexact")
	  plot_cntl(PLOT_MODE&32? "ylog":"-ylog")
	  plot_cntl(PLOT_MODE&256? "-dots":"dots")
	  plot_cntl(PLOT_MODE&512? "-lines":"lines")
	  plot_cntl(PLOT_MODE&1024? "-ebars":"ebars")

        # plot range
	  plot_range("auto","auto","auto","auto")

        # title, y-axis label, x-axis label
        plot_str = sprintf("%s, nave=%d, last scan=%d, BAD=%d", \
                            RS_SCAN_TITLE,nscans, SCAN_N, summary_data[0][0]);
#printf("%s\n",plot_str);
	  plot_move(15,0,plot_str)

        plot_str = sprintf("Ave(%s/%s)", cnt_mne(DET), cnt_mne(MON));
	  plot_move(0,0,plot_str)

	  plot_move(0,-1,sprintf("%.8s", pl_xl))

        plot_str = sprintf("Y_max=%g, at X=%g, fwhm=%g, cfwhm=%g, lhmx=%g, uhmx=%g", \
                            summary_data[0][1], summary_data[0][2], \
                            summary_data[0][3], summary_data[0][4], \
                            summary_data[0][5], summary_data[0][6] ) 
#printf("%s\n",plot_str);
	  plot_move(10,1,plot_str);

        plot_str = sprintf("I=%g, prsd=%g, Itot=%g, BGR=%g, AVE_BGR=%g", \
                             summary_data[0][7], summary_data[0][8],      \
                             summary_data[0][9], summary_data[0][10], \
                             summary_data[0][11]) 

#printf("%s\n",plot_str);
	  plot_move(10,2,plot_str);
 
        plot_move(0,4)

}'
####################################################################

