############################################################################
############################################################################
## site_standard.mac
## Use this to replace standard macros from
##      /usr/lib/spec.d/standard.mac 
##  or add new (simple) macros which will be used for any spec version
## 
## Note this file is read on a fresh start of spec 
##     ( either ">psic -f" or ">kappa -f" )
## Before defining a new macro type lsdef in spec to see
## if the name is already defined
##
############################################################################


############################################################################
############################################################################
#                 convinient shortcut macros                               #
############################################################################
############################################################################
       
############################################################################
# traj_scans
# Scan macros for trajectory scanning with EPICS and the MM4005
# This defines macros to turn trajectory scanning on and off

def traj_scans_on '{
    local t
    t = USERMAC "/traj_scans1.mac"
    qdofile(t)
    IS_TRAJ_SCAN = 1;
}'

def traj_scans_off '{
    local t
    t = USERMAC "/point_scans1.mac"
    qdofile(t)
    IS_TRAJ_SCAN = 0;
}'

############################################################################
def ton ' traj_scans_on '
############################################################################

############################################################################
def toff ' traj_scans_off '
############################################################################

############################################################################
def GSE ' GSE_MACROS '
############################################################################

############################################################################
def sh ' unix() '
############################################################################

############################################################################
def sor ' or_swap '
############################################################################

############################################################################
# macro to run a file defined in the USERMAC directory
def do_user_mac '{ 
  local t
  t = USERMAC "/" $1
  qdofile(t)      
}'
############################################################################


############################################################################
############################################################################
#                 Replacements for standard macros                         #
############################################################################
############################################################################

############################################################################
## gse_cleanup
## Note the "cleanup_always" macro is always called when cntrl-c or error ...
## The cleanup_always and cleanup_once macros are replecements for the 
## _scanabort macro (which is always executed when cntl-c during a scan)... 
## 
## First delete previous defined "gse" part
cdef("cleanup_always","","gse","delete");

def gse_cleanup '{    
    print "gse_cleanup"
    if(IS_FAKE_SCAN){
        fake_dscan_cleanup
    }
    if(IS_ROD_SCAN){
        rod_scan_cleanup;
        close(RS_SUM_FILE);
    } 
  
}'

cdef("cleanup_always"," ; gse_cleanup; ","gse");

## Note the other way to get a "cleanup macro" called when get cntrl-c or error
## is to use the following:
## def my_macro '{
##     cdef("cleanup_once","my_cleanup","my_cleanup_key");
##         .....
##         .....
##     cdef("cleanup_once","","my_cleanup_key","delete");
## }'
##
###########################################################################

############################################################################
## this is executed after any motor move
## see def of move_em
## wait for feedback to lock after any move ... 
def user_postmove '{ 
      while (epics_get("13IDA:E:Moving") == "Busy") sleep(0.1)
     # while (epics_get("13IDA:E:Moving") == 1) sleep(0.1)
}'
############################################################################

############################################################################
## user_precount
## executed before a count in standard.mac, see def of scan_count --> count
## use to make sure the mono feedback is locked
## bf counting (note: this is not called during traj_scans...)
def user_precount '{

   if ( epics_get("13IDA:mono_pid1.FBON") ==  "On" ){
      if (epics_get("13IDA:mono_pid1Locked") == 0) printf("Waiting for beam\n")
      while (epics_get("13IDA:mono_pid1Locked") == 0) sleep(0.1)
   }

}'
############################################################################

############################################################################
## setup mca detectors
## use this macro to assign values to the globals controlling how the
## mca_det is used
##
## globals
global USE_MCA
global WRITE_MCA_FILE
global MCA_FNAME
global MCA_PV_NAME
global MCA_ROI_PV_NAME
if( unset("USE_MCA") )            USE_MCA = FALSE;
if( unset("WRITE_MCA_FILE") )     WRITE_MCA_FILE = FALSE;
if( unset("MCA_FNAME") )          MCA_FNAME = "";
if( unset("MCA_PV_NAME") )        MCA_PV_NAME = "";
if( unset("MCA_ROI_PV_NAME") )    MCA_ROI_PV_NAME = "";


def setup_mca '{
     local num_mca
     num_mca = mca_sel("?")

     # loop through and disable all the devices
     # for (j=1,j<=num_mca,j++)  mca_spar(j,"disable",1)

     USE_MCA = getval("Enter 1 to turn on mca, 0 for off",USE_MCA)

     if (USE_MCA){
         # If we can get the device names ...
         # name = mca_par("device_id")
         # or mca_spar(j,"device_id")
         # then print the options and choose the detector from the list
         #
         # select the detector
         # mca_sel(xx)
         # this is now the detector which gets all the mca_par calls..
         #
         # enable the detector
         # and turn on reset (ie hit erase start button)
         mca_par("disable",0)
         mca_par("soft_preset",1)

         # below we should get automatically..
         # if we have the det names
         MCA_ROI_PV_NAME    = getval("Enter mca ROI PV name","13IDC:aim_adc1.RO");
         WRITE_MCA_FILE = getval("Enter 1 to dump spectra files, 0 for off",WRITE_MCA_FILE)
         if (WRITE_MCA_FILE){
            MCA_PV_NAME  = getval("Enter mca PV name","13IDC:aim_adc1");
         }
     }

}'


############################################################################
## user_getcounts
## user_getcounts is called in the macro get_counts
## which is called from scan_count within the _loop macro 
## its used here to add an epics pv to the scalers
## Note this will only be used during point scans!
## ie its not called during traj scans
##
## scalar 5 is a dummy scalar, use this to store the value of an 
## roi from an epics mca detector.
##
## note for an med may want to put the sum of all the detectors 
## into the scalar??

def user_getcounts '{
    local pv, pv_roi, fname, ret
    if (USE_MCA){

         # need this to wait for mca software to finish the calc
         sleep(.3)

         # if med maybe should sum over the channels
         pv_roi = MCA_ROI_PV_NAME
         s[5] = epics_get(pv_roi)

         if(WRITE_MCA_FILE){
             pv = MCA_PV_NAME
             # should use scanf here...
             #fname = DATAFILE "_" SCAN_N "_" NPTS ".xrf"
             #str = sprintf("write_mca  %s  %s",pv,fname)
             # ret val is 1 if it couldnt write the file
             #ret = unix(str)

             # if using the idl routine will want to poll on the busy field
         }
    }

  
    #S[5] = epics_get("13IDC:aim_adc1.R0")
    #S[5] = epics_get("13IDC:aim_adc1.R0N")
    #S[5] = 0

}'
###########################################################################


#########################################################################
# The loop macro, called by all the scans at each iteration
def _loop '{
	local z,i,n

      # if its a point scan we need to get the counts
      # traj scans already has the counts so we can skip this
      if (IS_TRAJ_SCAN == 0) {
	    if (!set_sim(-1) && _sleep) {
              do_sleep _sleep
	    }
          # if its a fake scan get the fake vals
          if (IS_FAKE_SCAN == 1){
             fake_scan_count _ctime
          } else {
 	       measure0
             scan_count _ctime
	       measure1
	       measure2
          }
      }

	z = _ctime < 0? sec:MON
	T_AV += DEGC;
	if (z >= 0)
		MT_AV += S[z]
	s = sprintf("%3d %s%8.0f ", NPTS,VPRNT,S[DET])

	tty_cntl("resized?")
	n = int((COLS - length(VPRNT) - length(Pout) - 24) / 9)
	if (MON >= 0) {
		s = s sprintf("%8.0f ", S[MON])
		n--
	}
	s = s sprintf("%10.6g ",S[sec])

	for (i=0; i<COUNTERS && n>0; i++) {
		if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
			s = s sprintf("%8.4g ", S[i])
			n--
		}
	}

	printf("%s%s\n",s,Pout)

	ifp {
		fprintf(PRINTER,"%3d %s %8.6g ", NPTS,_hkl_val11,S[sec])
		if (MON >= 0)
			fprintf(PRINTER,"%8.0f ", S[MON])
		fprintf(PRINTER,"%8.0f %s%s\n", S[DET],PPRNT,Pout)
	}
	if (DATAFILE != "") {
		fprintf(DATAFILE,"%s%s%d",FPRNT,Fout,(TIME_END=time())-EPOCH)
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				fprintf(DATAFILE," %g",S[i])
		if (z >= 0)
			fprintf(DATAFILE," %g",S[z])
		fprintf(DATAFILE," %g\n",S[DET]);
	}
        user_scan_loop
}'
#########################################################################


############################################################################
# Add stuff to data files
# (see pg 149 in spec manual)
# the Fheader increments _cols for number of output cols in _loop
# and puts the #X_ ... into the scan header
# Flabel and Fout put extra info into the data cols in _loop 

def Fheader  '_cols = _cols+2; 
              if(IS_ROD_SCAN) printf("%s\n", RS_SCAN_TITLE);
              printf("#ATTEN %d %d %d %d\n", ATTEN[0], ATTEN[1], ATTEN[2], ATTEN[3] );
              printf("#ALP_BET %g %g\n", ALPHA, BETA);
             '
def Flabel  '"Alpha  Beta  "'
def Fout  'sprintf("%7.5g  %7.5g  ", ALPHA, BETA)'  

############################################################################

#########################################################################
#
# The head macro, called by all the scans. at the start of the scan....
# ie this initializes the scan data and prints the header etc....
#
def _head '
	user_prescan_head
	_scan_time

      # see if this is a fake scan
      if (IS_FAKE_SCAN == 1){
         # if it is a fake scan see if the motors are really moving
         if ( FS_MOVE == 1) {
              # if yes get the current positions and HKL
              waitall; get_angles; calcHKL
          }
       # if its not a fake scan get the current positions and HKL
       } else {
         waitall; get_angles; calcHKL
       }

	NPTS = T_AV = MT_AV = 0
	DATE = date()
	TIME = TIME_END = time()
	_cp = A[_pmot]
	cdef("cleanup_once", "_scanabort;", "scan_cleanup")

	# DATA FILE HEADER
	if (DATAFILE != "") {
		local i,j,z,s
		ond; offt
		printf("\n#S %d  %s\n#D %s\n",++SCAN_N,HEADING,DATE)
		if (_ctime < 0)
			printf("#M %g  (%s)\n", -_ctime, cnt_name(MON))
		else
			printf("#T %g  (%s)\n", _ctime, cnt_name(sec))

 
           # T2 print out the geometry data in the scan header
           # added the UB and Q arrays to the output    
		_head_par G 0
		_head_par U 1
            _head_par UB 3
            _head_par Q 4

		printf("#Q %s\n", _hkl_val)

		for (i=0; i<MOTORS; i+= 8) {
			s = sprintf("#P%d ",i/8)
			for (j=i; j<i+8 && j<MOTORS;) {
				if (motor_name(mA[j]) != "unused")
					s = s sprintf("%.8g", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
		}
		Fheader
		user_Fheader
		z = _ctime < 0? sec:MON
		for (i=j=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				j++
		printf("#N %d\n", _cols + (MON<0? 2:3) + j)
		_cols = 0
		printf("#L %s%sEpoch",FPRNT,Flabel)
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				printf("  %s",cnt_name(i))
		if (z >= 0)
			printf("  %s",cnt_name(z))
		printf("  %s\n",cnt_name(DET))
		offd; ont
	} else
		SCAN_N++
	T_L = sprintf("Scan %d", SCAN_N)

	# PRINTER HEADER
	ifp {
		local i, j, k, s
		onp; offt
		printf("\n")
		formfeed
		printf("\nScan %3d   %s   file = %s  %s  user = %s\n",\
			SCAN_N,DATE,DATAFILE,TITLE,USER)
		printf("%s\n\n",HEADING)
		for (i=0; i<MOTORS; i+=8) {
			s = "  "
			for (j=i; j<i+8 && j<MOTORS;) {
				if (is_using_motor(mA[j]))
					s = s sprintf("%9.9s", motor_name(mA[j]))
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
			s = "  "
			for (j=i; j<i+8 && j<MOTORS;) {
				if (is_using_motor(mA[j]))
					s = s sprintf("%9.6g ", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
		}
		Pheader
		user_Pheader
		printf("\n  # %s %8.8s ", _hkl_sym11,cnt_name(sec))
		if (MON >= 0)
			printf("%8.8s ", cnt_name(MON))
		printf("%8.8s %s%s\n", cnt_name(DET),PPRNT,Plabel)
		offp; ont
	}
	# TTY HEADER
	{
		local i, n, s

		if (DATAFILE == "/dev/null" || DATAFILE == "null")
			s = "**NO DATA FILE**"
		else
			s = sprintf("file = %s", DATAFILE)
		printf("\nScan %3d   %s   %s  %s  user = %s\n%s\n\n",\
			SCAN_N,DATE,s,TITLE,USER,HEADING)
		s = sprintf("  # %s%8.8s ", VPRNT,cnt_name(DET))

		tty_cntl("resized?")
		n = int((COLS - length(VPRNT) - length(Plabel) - 24) / 9)
		if (MON >= 0) {
			s = s sprintf("%8.8s ",cnt_name(MON))
			n--
		}
		s = s sprintf("%10.10s ",cnt_name(sec))

		for (i=0; i<COUNTERS && n>0; i++) {
			if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
				s = s sprintf("%8.8s ", cnt_name(i))
				n--
			}
		}
		printf("%s%s\n",s,Plabel)
	}
	user_postscan_head
'

#########################################################################


############################################################################
## expanded this macro so it shows name and mne (vs _mot in standard.mac)
#
# show current (geometry) motor postions, only user units
def _mot '{
	local s[]
	s[0] = "name"
      s[1] = "mne"
	s[2] = "user"
	show_motor_info(s, 3, $#==1? $1:MOTORS)
}'
############################################################################


############################################################################
#### changed below macro from standard.mac to display 9 motors per line  
#### and add a newline between them
#
# Internal macro used to display motor information at 8 motors per line.
# Listing of motors named "unused" or that are disabled is suppressed.
# First argument is array of info-types as "name", "mne", "user",
# "dial", "lim+", "lim-", "ulim+" and "ulim-".  Second argument
# is number of elements in array.  Third argument is number of motors.
# If first argument is a single string as above, that is okay.
def show_motor_info(f, ns, n) '{
    local i, j, k, m, s[], t
    for (i=0; i<n && i<MOTORS; i++) {
	for (k=0;k<ns;k++)
	    s[k]=""
	for (j=0; i<n && i<MOTORS; i++) {
	    if (!is_using_motor(mA[i]))
		continue;
	    for (k=0;k<ns;k++) {
		m = mA[i]
		t = (whatis("f")&0x01000000)? f[k]:f
		if (t =="name")
		    s[k] = s[k] sprintf("%9.9s", motor_name(m))
		else if (t == "mne")
		    s[k] = s[k] sprintf("%9.9s", motor_mne(m))
		else if (t == "user")
		    s[k] = s[k] sprintf("%9.4f", A[m])
		else if (t == "dial")
		    s[k] = s[k] sprintf("%9.4f", dial(m, A[m]))
		else if (t == "lim+")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, +1))
		else if (t == "ulim+")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, +1)))
		else if (t == "lim-")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, -1))
		else if (t == "ulim-")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, -1)))
	    }
	    if (j%9 == 8)
		break
	    for (k=0;k<ns;k++)
		s[k] = s[k] " "
	    j++
	}
	#for (k=0;k<ns;k++)
	#    p s[k] 
      for (k=0;k<ns;k++){
	    p s[k]
      }
      p "\n" 
    }
}'
############################################################################


