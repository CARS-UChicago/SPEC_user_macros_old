############################################################################
############################################################################
## site_standard.mac
## Use this to replace standard macros from
##      /usr/lib/spec.d/standard.mac 
##  or add new (simple) macros which will be used for any spec version
## 
## Note this file is read on a fresh start of spec 
##     ( either ">psic -f" or ">kappa -f" )
## Before defining a new macro type lsdef in spec to see
## if the name is already defined
##
## Note check for hacks 3-20-03, make med work!! T2
##  modified user_get_counts, Fheader...
##
############################################################################


############################################################################
############################################################################
#                 convinient shortcut macros                               #
############################################################################
############################################################################
       
############################################################################
# traj_scans
# Scan macros for trajectory scanning with EPICS and the MM4005
# This defines macros to turn trajectory scanning on and off

def traj_scans_on '{
    local t
    t = USERMAC "/traj_scans1.mac"
    qdofile(t)
    IS_TRAJ_SCAN = 1;
}'

def traj_scans_off '{
    local t
    t = USERMAC "/point_scans1.mac"
    qdofile(t)
    IS_TRAJ_SCAN = 0;
}'

############################################################################
def ton ' traj_scans_on '
############################################################################

############################################################################
def toff ' traj_scans_off '
############################################################################

############################################################################
def GSE ' GSE_MACROS '
############################################################################

############################################################################
def sh ' unix() '
############################################################################

############################################################################
def sor ' or_swap '
############################################################################

############################################################################
# macro to run a file defined in the USERMAC directory
def do_user_mac '{ 
  local t
  t = USERMAC "/" $1
  qdofile(t)      
}'
############################################################################



############################################################################
############################################################################
#                 Replacements for standard macros                         #
############################################################################
############################################################################

############################################################################
## gse_cleanup
## Note the "cleanup_always" macro is always called when cntrl-c or error ...
## The cleanup_always and cleanup_once macros are replecements for the 
## _scanabort macro (which is always executed when cntl-c during a scan)... 
## 
## First delete previous defined "gse" part
cdef("cleanup_always","","gse","delete");

def gse_cleanup '{    
    print "gse_cleanup"
    if(IS_FAKE_SCAN){
        fake_dscan_cleanup
    }
    if(IS_ROD_SCAN){
        rod_scan_cleanup;
        close(RS_SUM_FILE);
    } 
    if(IS_EPICS_MED_COUNT){
       # IS_EPICS_MED_COUNT = FALSE;
    }
  
}'

cdef("cleanup_always"," ; gse_cleanup; ","gse");

## Note the other way to get a "cleanup macro" called when get cntrl-c or error
## is to use the following:
## def my_macro '{
##     cdef("cleanup_once","my_cleanup","my_cleanup_key");
##         .....
##         .....
##     cdef("cleanup_once","","my_cleanup_key","delete");
## }'
##
###########################################################################

############################################################################
## this is executed after any motor move
## see def of move_em
## wait for feedback to lock after any move ... 
def user_postmove '{ 
      while (epics_get("13IDA:E:Moving") == "Busy") sleep(0.1)
     # while (epics_get("13IDA:E:Moving") == 1) sleep(0.1)
}'
############################################################################

############################################################################
## user_precount
## executed before a count in standard.mac, see def of scan_count --> count
## use to make sure the mono feedback is locked
## bf counting (note: this is not called during traj_scans...)
def user_precount '{

#   if ( epics_get("13IDA:mono_pid1.FBON") ==  "On" ){
#      if (epics_get("13IDA:mono_pid1Locked") == 0) printf("Waiting for beam\n")
#      while (epics_get("13IDA:mono_pid1Locked") == 0) sleep(0.1)
#   }
   if ( epics_get("13IDA:mono_pid2.FBON") ==  "On" ){
      if (epics_get("13IDA:mono_pid2Locked") == 0) printf("Waiting for beam\n")
      while (epics_get("13IDA:mono_pid2Locked") == 0) sleep(0.1)
   }


}'
############################################################################

############################################################################
## check_beam
## use to make sure the mono feedback is locked
## bf counting (note: this is not called during traj_scans...)
def check_beam '{

   #if ( epics_get("13IDA:mono_pid1.FBON") ==  "On" ){
   #   if (epics_get("13IDA:mono_pid1Locked") == 0) printf("Waiting for beam\n")
   #   while (epics_get("13IDA:mono_pid1Locked") == 0) sleep(0.1)
   #}
   if ( epics_get("13IDA:mono_pid2.FBON") ==  "On" ){
      if (epics_get("13IDA:mono_pid2Locked") == 0) printf("Waiting for beam\n")
      while (epics_get("13IDA:mono_pid2Locked") == 0) sleep(0.1)
   }


}'
############################################################################

############################################################################
## setup mca detectors
## use this macro to set up the use of mca detector
## This assumes that the mca is set up in the spec config file
## 
## globals
global USE_MCA
global MCA_ROI_PV_NAME
global MCA_ROI_PV_NAME_2
global MCA_ROI_PV_NAME_3

if( unset("USE_MCA") )            USE_MCA = FALSE;
if( unset("MCA_ROI_PV_NAME") )    MCA_ROI_PV_NAME = "";
if( unset("MCA_ROI_PV_NAME") )    MCA_ROI_PV_NAME_2 = "";
if( unset("MCA_ROI_PV_NAME") )    MCA_ROI_PV_NAME_3 = "";


def setup_mca '{
     local num_mca, j
     num_mca = mca_sel("?")

     # loop through and disable all the devices
     for (j=0;j<num_mca;j++)  mca_spar(j,"disable",1)

     USE_MCA = getval("Enter 1 to turn on mca, 0 for off",USE_MCA)

     if (USE_MCA){
         # If we can get the device names ...
         # name = mca_par("device_id")
         # or mca_spar(j,"device_id")
         # then print the options and choose the detector from the list
         #
         # select the detector
         # mca_sel(xx)
         # this is now the detector which gets all the mca_par calls..
         #
         # enable the detector
         # and turn on reset (ie erase before start )
         mca_par("disable",0)
         mca_par("soft_preset",1)

         # below we should get automatically..
         # if we have the det names
         MCA_ROI_PV_NAME    = getval("Enter mca ROI PV name","13IDC:aim_adc1.R0");
         MCA_ROI_PV_NAME_2    = getval("Enter mca ROI PV name","13IDC:aim_adc1.R1");
         MCA_ROI_PV_NAME_3    = getval("Enter mca ROI PV name","13IDC:aim_adc1.R2");

     }

}'

############################################################################
## epics_med_count
## use to trigger an epics MED and an epics scaler
## This routine is used in place of specs count routine when you want 
## run with an MED and scaler.  Note that the spec count routine already
## handles an EPCIS MCA, so thats not included here.  
## To read the rois for the MED (and MCA) see the user_getcounts macro
## 

# globals
# use below flag in _loop macro 
global IS_EPICS_MED_COUNT
global MED_PV
global MED_NUM_DET
array ICR_ARRAY[4]

if( unset("IS_EPICS_MED_COUNT") )   IS_EPICS_MED_COUNT = FALSE
if( unset("MED_PV") )               MED_PV = ""
if( unset("MED_NUM_DET") )          MED_NUM_DET = 16
if( IS_EPICS_MED_COUNT == FALSE ) array MED_BAD_DETS[16]

##
def setup_med '{
     local j, str

     IS_EPICS_MED_COUNT = getval("Enter 1 to use MED, 0 for off",IS_EPICS_MED_COUNT)
     if(IS_EPICS_MED_COUNT){
            MED_PV = getval("Enter MED pv prefix","13GE1:med:")
            MED_NUM_DET = getval("Enter the number of detectors",16)
            for(j=0;j<16;j++){
                  str = "Enter 1 if detector is bad, 0 for ok: det "
                  str = sprintf("%s %d",str, j+1)
                  MED_BAD_DETS[j] = getval(str,MED_BAD_DETS[j])
            }
     }

}'

##
def med_on ' 
   IS_EPICS_MED_COUNT = TRUE 

   if ($# < 1){
      MED_WRITE_FILES = getval("Enter 1 to write med files, 0 for off",MED_WRITE_FILES)
      if (MED_WRITE_FILES){
        # this only works with python version
        MED_DATA_DIR = getval("Enter med data dir",MED_DATA_DIR)
      }
   } else {
      MED_WRITE_FILES = $1
   }
   print "MED_ON" 
'
def med_off ' 
   IS_EPICS_MED_COUNT = FALSE
   print "MED_OFF" 
'

def ep_cnt ' epics_med_count '

######################################
##  New version!!!
##  This requires a scanner database
##  and external prog for writing data files...
##

MED_WRITE_FILES = FALSE
MED_DATA_DIR = '.'

def epics_med_count2 '{
     # local cnt_time_val, sc_pv, med_pv
     # local sc_prtm_pv, sc_cnt_pv  
     # local med_prtm_pv, med_cnt_pv, med_acq_pv   

     if ($# != 1){
         eprint "Useage: time "
         exit
     } 

     if (MED_PV == ""){
         eprint "MED_PV unset"
         exit
     }

     cnt_time_val = $1

     # base pv names, assume scaler 0 is an epics device
     # thats being used for all the scaler detectors
     sc_pv = counter_par(0,"device_id");
     med_pv = MED_PV;

     # preset time and count for scaler
     sc_prtm_pv = sprintf("%s.%s",sc_pv,"TP") 
     sc_cnt_pv  = sprintf("%s.%s",sc_pv,"CNT")

     # preset time, EraseStart, Aquiring
     # and client wait pvs
     med_prtm_pv = sprintf("%s%s",med_pv,"PresetReal")
     sleep(.3)
     med_cnt_pv  = sprintf("%s%s",med_pv,"EraseStart")
     med_acq_pv  = sprintf("%s%s",med_pv,"Acquiring")

   
     # put the count times
     epics_put(sc_prtm_pv,cnt_time_val)
     epics_put(med_prtm_pv,cnt_time_val)
 

     # user pre count stuff
     user_precount

     # hit the triggers and wait for done
     epics_put(med_cnt_pv,1)
     while( epics_get(med_acq_pv) == 0) sleep(0.1);
     epics_put(sc_cnt_pv,1)

     # wait for scaler and med to finish
     status = 1
     sc_done = FALSE
     med_done = FALSE
     cw_busy  = FALSE
     while(status){
        sleep(0.1)
        if (epics_get(sc_cnt_pv)=="Done"){
             sc_done = TRUE;
            # p "scaler done"
        }
        if (epics_get(med_acq_pv) == 0){
            med_done = TRUE;
           # p "med done"
        }
        if( (sc_done==TRUE) && (med_done==TRUE) ) status = 0;
     }

     # write files if want em
     if ( MED_WRITE_FILES == TRUE ) {

         # scanner data base pvs
         med_request_write_pv   = "13IDC:edb:Request"
         med_request_go = 1
         med_request_done = 0
         med_file_pv   = "13IDC:edb:file"
         med_dir_pv   = "13IDC:edb:dir"

         # make file name
         nstr = split(DATAFILE,splt_str,"/") 
         med_fname = sprintf("%s_%.3d.%.3d",splt_str[nstr-1],SCAN_N,NPTS)
      
         # put to the data base
         # note looks like spec cant handle waveform records,
         # ie these epics_puts dont work, therefore
         # have to use shell!!!!!

         ###epics_put(med_file_pv,med_fname)
         cmd_string =  sprintf("caput %s %s" ,med_file_pv, med_fname)
         unix(cmd_string)

         ###epics_put(med_dir_pv,MED_DATA_DIR)
         cmd_string =  sprintf("caput %s %s" ,med_dir_pv, MED_DATA_DIR)
         unix(cmd_string)

         # ask for write file
         sleep(0.1)
         epics_put(med_request_write_pv,med_request_go)
         check_request_stat = med_request_go
         #print "here1"
         #print check_request_stat
         while ( check_request_stat == med_request_go){
             #print "here"
             check_request_stat = epics_get(med_request_write_pv,"short")              
             #print check_request_stat
             sleep(0.2)
         }

     }

     # use the get_counts routine to read the scalers
     # note get_counts also calls user_getcounts
     # thats where the rois get read.
     get_counts

}'

########################################################
##  Original version using the client wait field of med    
##
def epics_med_count '{
     # local cnt_time_val, sc_pv, med_pv
     # local sc_prtm_pv, sc_cnt_pv  
     # local med_prtm_pv, med_cnt_pv, med_acq_pv   

     if ($# != 1){
         eprint "Useage: time "
         exit
     } 

     if (MED_PV == ""){
         eprint "MED_PV unset"
         exit
     }

     cnt_time_val = $1

     # base pv names, assume scaler 0 is an epics device
     # thats being used for all the scaler detectors
     sc_pv = counter_par(0,"device_id");
     med_pv = MED_PV;

     # preset time and count for scaler
     sc_prtm_pv = sprintf("%s.%s",sc_pv,"TP") 
     sc_cnt_pv  = sprintf("%s.%s",sc_pv,"CNT")

     # preset time, EraseStart, Aquiring
     # and client wait pvs
     med_prtm_pv = sprintf("%s%s",med_pv,"PresetReal")
     med_cnt_pv  = sprintf("%s%s",med_pv,"EraseStart")
    #med_cnt_pv  = sprintf("%s%s",med_pv,"StartAll")
     med_acq_pv  = sprintf("%s%s",med_pv,"Acquiring")
     med_ecw_pv   = sprintf("%s%s",med_pv,"EnableClientWait")
     med_cw_pv   = sprintf("%s%s",med_pv,"ClientWait")
     med_cw_desc_pv = sprintf("%s%s",med_pv,"ClientWait.DESC")

     # put the count times
     epics_put(sc_prtm_pv,cnt_time_val)
     epics_put(med_prtm_pv,cnt_time_val)
 

     # put the file name in case we are dumping spectra files
     {
     #med_fname = DATAFILE "_" SCAN_N "_" NPTS ".xrf"
     nstr = split(DATAFILE,splt_str,"/") 
     # med_fname = sprintf("%s_%.3d_%.3d.xrf",splt_str[nstr-1],SCAN_N,NPTS)
     med_fname = sprintf("%s_%.3d.%.3d",splt_str[nstr-1],SCAN_N,NPTS)
     epics_put(med_cw_desc_pv,med_fname)
     #xx = epics_get(med_cw_desc_pv)
     #print xx
     sleep(0.3)
     epics_put(med_cw_desc_pv,med_fname)
     #sleep(0.1)
     epics_put(med_cw_desc_pv,med_fname)
     }

     # user pre count stuff
     user_precount

     # hit the triggers and wait for done
     epics_put(med_cnt_pv,1)
     while( epics_get(med_acq_pv) == 0) sleep(0.1);
     epics_put(sc_cnt_pv,1)

     # wait for scaler and med to finish
     status = 1
     sc_done = FALSE
     med_done = FALSE
     cw_busy  = FALSE
     while(status){
        sleep(0.3)
        if (epics_get(sc_cnt_pv)=="Done"){
             sc_done = TRUE;
             #p "scaler done"
        }
        if (epics_get(med_acq_pv) == 0){
            med_done = TRUE;
            #p "med done"
        }
        if (MED_WRITE_FILES==TRUE){
           # wait for client wait to go done if 
           # client wait is enabled
           if( epics_get(med_ecw_pv,"short") == 1){
               cw_busy =  epics_get(med_cw_pv,"short")
           }
        } else {
           cw_busy = FALSE
        }
        if( (sc_done==TRUE) && (med_done==TRUE) && (cw_busy==FALSE) ) status = 0;
     }

     # if client wait is enabled wait for the client wait
     # field to go done
     #p "here"
     #p epics_get(med_ecw_pv,"short") 
     #if( epics_get(med_ecw_pv,"short") == 1){
     #   p epics_get(med_cw_pv,"short")
     #   while( epics_get(med_cw_pv,"short") == 1) {
     #       sleep(0.1);
     #       p "waiting for client"
     #   }
     #}

     # use the get_counts routine to read the scalers
     # note get_counts also calls user_getcounts
     # thats where the rois get read.
     get_counts
   
     sleep(1)
     

}'
#
#
#
#
############################################################################
## user_getcounts
## user_getcounts is called in the macro get_counts
## which is called from scan_count within the _loop macro 
## its used here to add an epics pv to the scalers
## Note this will only be used during point scans!
## ie its not called during traj scans
##
## scalar 5 is a dummy scalar, use this to store the value of an 
## roi from an epics mca detector.
##
## note for an med may want to put the sum of all the detectors 
## into the scalar??

def user_getcounts '{
    local pv_roi, j, pv

    if (USE_MCA){
         S[roi1] = 0; S[roi2] = 0; S[roi3] = 0;
         # need this to wait for mca software to finish the calc
         sleep(.3)
         pv_roi = MCA_ROI_PV_NAME
         S[roi1] = epics_get(pv_roi)
         pv_roi = MCA_ROI_PV_NAME_2
         S[roi2] = epics_get(pv_roi)
         pv_roi = MCA_ROI_PV_NAME_3
         S[roi3] = epics_get(pv_roi)
    } else if( (IS_EPICS_MED_COUNT==1) && (MED_PV != "") ) {
         S[roi1] = 0; S[roi2] = 0; S[roi3] = 0;
         for(j=0;j<MED_NUM_DET;j++ ){
            if( MED_BAD_DETS[j] != 1 ){
               #pv = sprintf("%smca%d.%s",MED_PV,j+1,"R0")
               pv = sprintf("%smca%d.%s",MED_PV,j+1,"R0N")
               S[roi1] = S[roi1] + epics_get(pv)

               #pv = sprintf("%smca%d.%s",MED_PV,j+1,"R1")
               pv = sprintf("%smca%d.%s",MED_PV,j+1,"R1N")
               S[roi2] = S[roi2] + epics_get(pv)

               #pv = sprintf("%smca%d.%s",MED_PV,j+1,"R2")
               pv = sprintf("%smca%d.%s",MED_PV,j+1,"R2N")
               S[roi3] = S[roi3] + epics_get(pv)
            }
         }
         #### 3-20-03, T2
         #### note used for ge det in 4-element mode!!!
         #### python catcher prog is broken!!!
         #### see the Fheader stuff etc....
         ICR_ARRAY[0] = 0; ICR_ARRAY[1] = 0; ICR_ARRAY[2] = 0; ICR_ARRAY[3] = 0;
         pv = "13GE1:med:scaler1.S4"
         ICR_ARRAY[0] = epics_get(pv)

         pv = "13GE1:med:scaler1.S8"
         ICR_ARRAY[1] = epics_get(pv)

         pv = "13GE1:med:scaler1.S12"
         ICR_ARRAY[2] = epics_get(pv)

         pv = "13GE1:med:scaler1.S16"
         ICR_ARRAY[3] = epics_get(pv)
    } 

 
    #pv = MCA_PV_NAME
    #fname, ret
    # should use scanf here...
    #fname = DATAFILE "_" SCAN_N "_" NPTS ".xrf"
    #str = sprintf("write_mca  %s  %s",pv,fname)
    # ret val is 1 if it couldnt write the file
    #ret = unix(str)
 

}'

###########################################################################


#########################################################################
# The loop macro, called by all the scans at each iteration
def _loop '{
	local z,i,n

      # if its a point scan we need to get the counts
      # traj scans already has the counts so we can skip this
      if (IS_TRAJ_SCAN == 0) {
	    if (!set_sim(-1) && _sleep) {
              do_sleep _sleep
	    }
          # if its a fake scan get the fake vals
          if (IS_FAKE_SCAN == 1){
             fake_scan_count _ctime
          }else if(IS_EPICS_MED_COUNT){
             epics_med_count _ctime
          } else {
 	       measure0
             scan_count _ctime
	       measure1
	       measure2
          }
      }

	z = _ctime < 0? sec:MON
	T_AV += DEGC;
	if (z >= 0)
		MT_AV += S[z]
	s = sprintf("%3d %s%8.0f ", NPTS,VPRNT,S[DET])

	tty_cntl("resized?")
	n = int((COLS - length(VPRNT) - length(Pout) - 24) / 9)
	if (MON >= 0) {
		s = s sprintf("%8.0f ", S[MON])
		n--
	}
	s = s sprintf("%10.6g ",S[sec])

	for (i=0; i<COUNTERS && n>0; i++) {
		if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
			s = s sprintf("%8.4g ", S[i])
			n--
		}
	}

	printf("%s%s\n",s,Pout)

	ifp {
		fprintf(PRINTER,"%3d %s %8.6g ", NPTS,_hkl_val11,S[sec])
		if (MON >= 0)
			fprintf(PRINTER,"%8.0f ", S[MON])
		fprintf(PRINTER,"%8.0f %s%s\n", S[DET],PPRNT,Pout)
	}
      # 
      # print data
      # 
	if (DATAFILE != "") {
		fprintf(DATAFILE,"%s%s%d",FPRNT,Fout,(TIME_END=time())-EPOCH)


		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				fprintf(DATAFILE," %g",S[i])

		if (z >= 0)
			fprintf(DATAFILE," %g",S[z])
		fprintf(DATAFILE," %g\n",S[DET]);
	}
        user_scan_loop
}'
#########################################################################


############################################################################
# Add stuff to data files
# (see pg 149 in spec manual)
# the Fheader increments _cols for number of output cols in _loop
# and puts the #X_ ... into the scan header
# Flabel and Fout put extra info into the data cols in _loop 

def Fheader  '_cols = _cols+2; 
              if(IS_ROD_SCAN) printf("%s\n", RS_SCAN_TITLE);
              printf("#ATTEN %d %d %d %d\n", ATTEN[0], ATTEN[1], ATTEN[2], ATTEN[3] );
              printf("#ALP_BET %g %g\n", ALPHA, BETA);
             '
###
###  Hack 3-20-03, T2
###
#def Flabel  '"Alpha  Beta  "'
#def Fout  'sprintf("%7.5g  %7.5g  ", ALPHA, BETA)' 
 
def Flabel  '"icr1  icr2  icr3  icr4  "'
def Fout 'sprintf("%7.5g  %7.5g  %7.5g  %7.5g  ", ICR_ARRAY[0], ICR_ARRAY[1],ICR_ARRAY[2],ICR_ARRAY[3])'


############################################################################

#########################################################################
#
# The head macro, called by all the scans. at the start of the scan....
# ie this initializes the scan data and prints the header etc....
#
def _head '
	user_prescan_head
	_scan_time

      # see if this is a fake scan
      if (IS_FAKE_SCAN == 1){
         # if it is a fake scan see if the motors are really moving
         if ( FS_MOVE == 1) {
              # if yes get the current positions and HKL
              waitall; get_angles; calcHKL
          }
       # if its not a fake scan get the current positions and HKL
       } else {
         waitall; get_angles; calcHKL
       }

	NPTS = T_AV = MT_AV = 0
	DATE = date()
	TIME = TIME_END = time()
	_cp = A[_pmot]
	cdef("cleanup_once", "_scanabort;", "scan_cleanup")

	# DATA FILE HEADER
	if (DATAFILE != "") {
		local i,j,z,s
		ond; offt
		printf("\n#S %d  %s\n#D %s\n",++SCAN_N,HEADING,DATE)
		if (_ctime < 0)
			printf("#M %g  (%s)\n", -_ctime, cnt_name(MON))
		else
			printf("#T %g  (%s)\n", _ctime, cnt_name(sec))

 
           # T2 print out the geometry data in the scan header
           # added the UB and Q arrays to the output    
		_head_par G 0
		_head_par U 1
            _head_par UB 3
            _head_par Q 4

		printf("#Q %s\n", _hkl_val)

		for (i=0; i<MOTORS; i+= 8) {
			s = sprintf("#P%d ",i/8)
			for (j=i; j<i+8 && j<MOTORS;) {
				if (motor_name(mA[j]) != "unused")
					s = s sprintf("%.8g", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
		}
		Fheader
		user_Fheader
		z = _ctime < 0? sec:MON
		for (i=j=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				j++
		printf("#N %d\n", _cols + (MON<0? 2:3) + j)
		_cols = 0
		printf("#L %s%sEpoch",FPRNT,Flabel)
            
		for (i=0;i<COUNTERS;i++)
			if (i != z && i != DET && is_using_counter(i))
				printf("  %s",cnt_name(i))
		if (z >= 0)
			printf("  %s",cnt_name(z))
		printf("  %s\n",cnt_name(DET))
		offd; ont
	} else
		SCAN_N++
	T_L = sprintf("Scan %d", SCAN_N)

	# PRINTER HEADER
	ifp {
		local i, j, k, s
		onp; offt
		printf("\n")
		formfeed
		printf("\nScan %3d   %s   file = %s  %s  user = %s\n",\
			SCAN_N,DATE,DATAFILE,TITLE,USER)
		printf("%s\n\n",HEADING)
		for (i=0; i<MOTORS; i+=8) {
			s = "  "
			for (j=i; j<i+8 && j<MOTORS;) {
				if (is_using_motor(mA[j]))
					s = s sprintf("%9.9s", motor_name(mA[j]))
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
			s = "  "
			for (j=i; j<i+8 && j<MOTORS;) {
				if (is_using_motor(mA[j]))
					s = s sprintf("%9.6g ", A[mA[j]])
				if (j%8 == 7)
					break
				s = s " "
				j++
			}
			print s
		}
		Pheader
		user_Pheader
		printf("\n  # %s %8.8s ", _hkl_sym11,cnt_name(sec))
		if (MON >= 0)
			printf("%8.8s ", cnt_name(MON))
		printf("%8.8s %s%s\n", cnt_name(DET),PPRNT,Plabel)
		offp; ont
	}
	# TTY HEADER
	{
		local i, n, s

		if (DATAFILE == "/dev/null" || DATAFILE == "null")
			s = "**NO DATA FILE**"
		else
			s = sprintf("file = %s", DATAFILE)
		printf("\nScan %3d   %s   %s  %s  user = %s\n%s\n\n",\
			SCAN_N,DATE,s,TITLE,USER,HEADING)
		s = sprintf("  # %s%8.8s ", VPRNT,cnt_name(DET))

		tty_cntl("resized?")
		n = int((COLS - length(VPRNT) - length(Plabel) - 24) / 9)
		if (MON >= 0) {
			s = s sprintf("%8.8s ",cnt_name(MON))
			n--
		}
		s = s sprintf("%10.10s ",cnt_name(sec))

		for (i=0; i<COUNTERS && n>0; i++) {
			if (i!=DET && i !=MON && i!=sec && is_using_counter(i)) {
				s = s sprintf("%8.8s ", cnt_name(i))
				n--
			}
		}
		printf("%s%s\n",s,Plabel)
	}
	user_postscan_head
'

#########################################################################


############################################################################
## expanded this macro so it shows name and mne (vs _mot in standard.mac)
#
# show current (geometry) motor postions, only user units
def _mot '{
	local s[]
	s[0] = "name"
      s[1] = "mne"
	s[2] = "user"
	show_motor_info(s, 3, $#==1? $1:MOTORS)
}'
############################################################################


############################################################################
#### changed below macro from standard.mac to display 9 motors per line  
#### and add a newline between them
#
# Internal macro used to display motor information at 8 motors per line.
# Listing of motors named "unused" or that are disabled is suppressed.
# First argument is array of info-types as "name", "mne", "user",
# "dial", "lim+", "lim-", "ulim+" and "ulim-".  Second argument
# is number of elements in array.  Third argument is number of motors.
# If first argument is a single string as above, that is okay.
def show_motor_info(f, ns, n) '{
    local i, j, k, m, s[], t
    for (i=0; i<n && i<MOTORS; i++) {
	for (k=0;k<ns;k++)
	    s[k]=""
	for (j=0; i<n && i<MOTORS; i++) {
	    if (!is_using_motor(mA[i]))
		continue;
	    for (k=0;k<ns;k++) {
		m = mA[i]
		t = (whatis("f")&0x01000000)? f[k]:f
		if (t =="name")
		    s[k] = s[k] sprintf("%9.9s", motor_name(m))
		else if (t == "mne")
		    s[k] = s[k] sprintf("%9.9s", motor_mne(m))
		else if (t == "user")
		    s[k] = s[k] sprintf("%9.4f", A[m])
		else if (t == "dial")
		    s[k] = s[k] sprintf("%9.4f", dial(m, A[m]))
		else if (t == "lim+")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, +1))
		else if (t == "ulim+")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, +1)))
		else if (t == "lim-")
		    s[k] = s[k] sprintf("%9.4f", get_lim(m, -1))
		else if (t == "ulim-")
		    s[k] = s[k] sprintf("%9.4f", user(m, get_lim(m, -1)))
	    }
	    if (j%9 == 8)
		break
	    for (k=0;k<ns;k++)
		s[k] = s[k] " "
	    j++
	}
	#for (k=0;k<ns;k++)
	#    p s[k] 
      for (k=0;k<ns;k++){
	    p s[k]
      }
      p "\n" 
    }
}'
############################################################################

############################################################################
# lup2
#

def lup2 '
        if ($# != 5) {
                eprint "Usage:  lup motor start finish intervals time"
                exit
        } 
        dscan $*      
        sc_an
  
  if (SC_AN_FWHM != 0){
       mv $1 SC_AN_CEN ;
       p "Moving motor to " SC_AN_CEN;
  }

'
############################################################################

############################################################################
# En_scan
# just calls Escan but takes start and stop in ev....
#

def Enscan '
        if ($# != 4) {
                eprint "Usage:  Enscan start finish intervals time"
                eprint " energies in eV"
                exit
        } 
        getE;
        lam1 = LAMBDA;
        Escan $1/1000 $2/1000 $3 $4;
        moveE hc_over_e/lam1;
        getE;      
  
 
'
############################################################################

