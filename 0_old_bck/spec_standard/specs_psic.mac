#++++ install source file:  /home/specadm/spec5.01.01/macros/README.mac
#  @(#)README.mac	5.1  01/29/01 CSS
#
# Please do not edit the standard CSS macro files.  When spec is
# updated or reinstalled, all such changes will get clobbered.  If
# you need to change the standard macros, place the modified
# macros in one of the following files, as appropriate.
#
#      SPECD/site_f.mac        (read only when starting fresh)
#      SPECD/site.mac          (read each time each user starts)
#      SPECD/fourc/conf.mac    (or sixc, spec, kappa, etc.)
#      ./spec.mac              (relative to start up directory)
#
# None of these files are created by the spec installation.  They
# are locally created and maintained files.  Each file, if it exists,
# is read in the order listed above, after the standard CSS macro
# files are read.  Macros definitions in the above files will replace any
# macros of the same name that were read from the standard CSS macro
# files.
#
# If you do need to change a standard macro for your site, please
# contact CSS so that, if practical, future versions of the standard
# macros will be redesigned to accommodate your needs.
#
#++++ install source file:  /home/specadm/spec5.01.01/macros/psic.src
#
#  @(#)psic.src	5.2  06/24/01 CSS
#
#  "Spec" Release 5
#
#  Copyright (c) 1998,1999,2000,2001
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################
#
#
#  Psi-circle spectrometer macros:

# The first _numgeo motors must agree with geo_psic.c for the UB
# macros to work (see ub.mac).
# The order in mA[] determines the order in which the motors are
# displayed.  _assign_mA assigns the remaining motors to mA as ordered
# in the config file

def _assign '{
	mA[0]=del
	mA[1]=eta
	if (motor_mne(chi) == "chi" && motor_mne(phi) == "phi") {
		mA[2]=chi
		mA[3]=phi
		mA[4]=nu
		mA[5]=mu
		_numgeo = 6
		_assign_mA 6
		constant is_s2d2 0
	} else {
		mA[2]=nu
		mA[3]=mu
		_numgeo = 4
		_assign_mA 4
		constant is_s2d2 1
	}
	if (motor_mne(kap) == "kap" \
	     && motor_mne(keta) == "keta" \
	       && motor_mne(kphi) == "kphi")
		constant is_kappa 1
	else
		constant is_kappa 0
}'
_assign

## These first macros are redefined for each particular geometry.

def ca '
	if ($# != 3) {
		eprint "Usage:  ca H K L"
		exit
	} ;
	{H = $1; K = $2; L = $3}
	if (calcA) {
		waitmove; get_angles; calcHKL
		exit
	}
	calcHKL
	onp
	printf("\nCalculated Positions:\n")
	_var
	offp
	waitmove; get_angles; calcHKL
'

# A macro called by "wh", "ca" and "ci" to display important
# geometry quantities.
def _var '
	printf("\nH K L =  %.5g  %.5g  %.5g", H,K,L)
	printf("\t Lambda = %.5g Two Theta = %.5g\n\n",\
		LAMBDA,TTH)
	printf("%9s %9s %9s %9s %9s %9s %9s\n",\
		"Alpha","Beta","Psi","Tau","Qaz","Naz","Omega");
	printf("%9.4f %9.4f %9.4f %9.4f %9.4f %9.4f %9.4f\n\n",\
		ALPHA,BETA,PSI,TAU,QAZ,NAZ,OMEGA)

	_mot _numgeo
'

# _hkl_lim does limit checking for motors used in general HKL scan.
rdef _hkl_lim is_kappa? '
	_chk_lim del A[del]
	_chk_lim nu  A[nu]
	_chk_lim mu  A[mu]
	_chk_lim keta A[keta]
	_chk_lim kap  A[kap]
	_chk_lim kphi A[kphi]
':'
	_chk_lim del A[del]
	_chk_lim eta A[eta]
	if (!is_s2d2) {
		_chk_lim chi A[chi]
		_chk_lim phi A[phi]
	}
	_chk_lim nu  A[nu]
	_chk_lim mu  A[mu]
'

# freeze (and unfreeze) depending on mode
# use current position if no arguments, otherwise use arguments.
def freeze 'f_freeze("$*")'

def f_freeze(s) '{
	local   i, n, a[]

	i = 0
	n = split(s, a)

	if (n == 0) { waitmove; get_angles }

	g_frz = 1
	if (g_mode1 == 1) {
		F_DEL = n-- > 0? a[i++]:A[del]
		fcom(sprintf("Freezing Delta at %g", F_DEL))
	} else if (g_mode1 == 2) {
		F_NU = n-- > 0? a[i++]:A[nu]
		fcom(sprintf("Freezing Nu at %g", F_NU))
	} else if (g_mode1 == 3 || g_mode1 == 5) {
		F_QAZ = n-- > 0? a[i++]:QAZ
		fcom(sprintf("Freezing Qaz at %g", F_QAZ))
		if (g_mode1 == 5)
			return
	} else if (g_mode1 == 4) {
		F_NAZ = n-- > 0? a[i++]:NAZ
		fcom(sprintf("Freezing Naz at %g", F_NAZ))
	}
	if (g_mode2 == 2) {
		F_ALPHA = n-- > 0? a[i++]:ALPHA
		fcom(sprintf("Freezing Alpha at %g", F_ALPHA))
	} else if (g_mode2 == 3) {
		F_BETA = n-- > 0? a[i++]:BETA
		fcom(sprintf("Freezing Beta at %g", F_BETA))
	} else if (g_mode2 == 4) {
		F_PSI = n-- > 0? a[i++]:PSI
		fcom(sprintf("Freezing Psi (azimuth) at %g", F_PSI))
	}
	if (g_mode3 == 1) {
		F_ETA = n-- > 0? a[i++]:A[eta]
		fcom(sprintf("Freezing Eta at %g", F_ETA))
	} else if (g_mode3 == 2) {
		F_MU = n-- > 0? a[i++]:A[mu]
		fcom(sprintf("Freezing Mu at %g", F_MU))
	} else if (!is_s2d2 && g_mode3 == 3) {
		F_CHI = n-- > 0? a[i++]:A[chi]
		fcom(sprintf("Freezing Chi at %g", F_CHI))
	} else if (!is_s2d2 && g_mode3 == 4) {
		F_PHI = n-- > 0? a[i++]:A[phi]
		fcom(sprintf("Freezing Phi at %g", F_PHI))
	}
	if (g_mode1 == 0 || g_mode2 == 0) {
		if (g_mode4 == 1) {
			F_ETA = n-- > 0? a[i++]:A[eta]
			fcom(sprintf("Freezing Eta at %g", F_ETA))
		} else if (g_mode4 == 2) {
			F_MU = n-- > 0? a[i++]:A[mu]
			fcom(sprintf("Freezing Mu at %g", F_MU))
		} else if (!is_s2d2 && g_mode4 == 3) {
			F_CHI = n-- > 0? a[i++]:A[chi]
			fcom(sprintf("Freezing Chi at %g", F_CHI))
		} else if (!is_s2d2 && g_mode4 == 4) {
			F_PHI = n-- > 0? a[i++]:A[phi]
			fcom(sprintf("Freezing Phi at %g", F_PHI))
		}
	}
	if (g_mode1 == 0 && g_mode2 == 0) {
		if (g_mode5 == 1) {
			F_ETA = n-- > 0? a[i++]:A[eta]
			fcom(sprintf("Freezing Eta at %g", F_ETA))
		} else if (g_mode5 == 2) {
			F_MU = n-- > 0? a[i++]:A[mu]
			fcom(sprintf("Freezing Mu at %g", F_MU))
		} else if (!is_s2d2 && g_mode5 == 3) {
			F_CHI = n-- > 0? a[i++]:A[chi]
			fcom(sprintf("Freezing Chi at %g", F_CHI))
		} else if (!is_s2d2 && g_mode5 == 4) {
			F_PHI = n-- > 0? a[i++]:A[phi]
			fcom(sprintf("Freezing Phi at %g", F_PHI))
		}
	}

	if (g_mode1 < 5 && g_mode2 == 0 && g_mode3 == 0 && g_mode4 == 0) {
		if (n-- > 0)
			F_OMEGA = a[i++]
		fcom(sprintf("Freezing Omega at %g", F_OMEGA))
	}
}'
def unfreeze '
	if (g_frz) {
		g_frz = 0
		comment "Frozen mode off"
	} else
		print "Frozen mode already off."
'
def fcurmode() '{
	local   t

	if (g_mode1 == 5)
		t = "5"
	else {
		t = sprintf("%d %d %d", g_mode1,g_mode2,g_mode3)
		if (g_mode1 == 0 || g_mode2 == 0)
			t = t sprintf(" %d", g_mode4)
		if (g_mode1 == 0 && g_mode2 == 0)
			t = t sprintf(" %d", g_mode5)
	}
	return(t)
}'

# Set geometry mode
def setmode '{
	_1 = g_mode1
	_2 = g_mode2
	_3 = g_mode3
	_4 = g_mode4
	_5 = g_mode5
	if ($#) {
		local len
		if ((len = length("$1")) > 1) {
			_1 = substr("$1",1,1)
			if (len > 1) _2 = substr("$1",2,1)
			if (len > 2) _3 = substr("$1",3,1)
			if (len > 3) _4 = substr("$1",4,1)
			if (len > 4) _5 = substr("$1",5,1)
		} else {
			_1 = $1
			if ($# > 1) _2 = $2
			if ($# > 2) _3 = $3
			if ($# > 3) _4 = $4
			if ($# > 4) _5 = $5
		}
	} else if ($# == 0) {
		local s

		print "\n\
	g_mode1      g_mode2      g_mode3      g_mode4      g_mode5\n\
0             .            .  omega-fixed            X            X  0\n\
1   Delta-fixed   Alpha=Beta    Eta-fixed    Eta-fixed    Eta-fixed  1\n\
2      Nu-fixed  Alpha-fixed     Mu-fixed     Mu-fixed     Mu-fixed  2\n\
3     Qaz-fixed   Beta-fixed    Chi-fixed    Chi-fixed    Chi-fixed  3\n\
4     Naz-fixed    Psi-fixed    Phi-fixed    Phi-fixed    Phi-fixed  4\n\
5          Zone            X    Eta=Del/2            X            X  5\n\
6             X            X      Mu=Nu/2            X            X  6\n\
"
		s = getval("\nNew mode", fcurmode())
		sscanf(s, "%d%d%d%d%d", _1, _2, _3, _4, _5)
	}

	gpset _1 g_mode1
	gpset _2 g_mode2
	gpset _3 g_mode3
	gpset _4 g_mode4
	gpset _5 g_mode5
	printf("\nCurrent mode:  %s (%s)\n", fpr_mode(), fcurmode())
}'

# Set configuration
def sigtau '{
	if ($# == 1) {
		_1 = $1
	} else if ($# == 0) {
		_1 = yesno("\n\
You can specify the azimuthal reference vector either\n\
by its HKL values or by the angles here called sigma\n\
and tau.  Do you want to use the angle method", g_sigtau)
	} else {
		eprint "Usage: sigtau  or  sigtau sigtau_mode"
		exit
	}
	gpset _1 g_sigtau
}'

# Set azimuthal reference
def setaz '{
	if (!is_s2d2 && g_sigtau) {
		if ($# == 1 && $1 == 1) {
		       _1 = A[chi]
		       _2 = A[phi]
		} else if ($# == 2) {
			_1 = $1; _2 = $2
		} else if ($# == 0) {
			print "\nEnter azimuthal sigma and tau:"
			_1 = getval(" Azimuthal sigma", SIGMA_AZ)
			_2 = getval(" Azimuthal tau", TAU_AZ)
		} else {
			eprint "Usage:  setaz  or  setaz sigma_az tau_az"
			exit
		}
		gpset _1 SIGMA_AZ
		gpset _2 TAU_AZ
	} else {
		if ($# == 3) {
			_1 = $1; _2 = $2; _3 = $3
		} else if ($# == 0) {
			print "\nEnter azimuthal reference H K L:"
			_1 = getval(" Azimuthal H", g_haz)
			_2 = getval(" Azimuthal K", g_kaz)
			_3 = getval(" Azimuthal L", g_laz)
		} else {
			eprint "Usage:  setaz  or  setaz H K L"
			exit
		}
		gpset _1 g_haz
		gpset _2 g_kaz
		gpset _3 g_laz
	}
	get_angles; calcHKL
}'

def fsect() '{
	local t

	if (g_sect == 0 && g_prefer == 0)
		t = "None"
	else if (g_sect == 0) {
		if (g_prefer == 1)
			t = "Pseudo-vertical preference"
		else if (g_prefer == 2)
			t = "Pseudo-horizontal preference"
		else
			t = "Unimplemented preference"
		t = t sprintf(" (%d)", g_prefer)
	} else if (1 <= g_sect && g_sect <= 16)
		t = sprintf("Fixed (%d)", g_sect)
	else
		t = sprintf("Unimplemented sector (%d)", g_sect)
	return(t)
}'
# Set preference
def prefer '
	if ($# == 1)
		_1 = $1
	else if ($# == 0) {
		_1 = getval("\nSelect transformation preference", g_prefer)
	} else {
		eprint "Usage:  prefer  or  prefer value"
		exit
	}
	gpset _1 g_prefer
	if (_1 != 0)
		gpset 0 g_sect
'
# Set sector
def sector '
	if ($# == 1)
		_1 = $1
	else if ($# == 0) {
		_1 = getval("\nSelect sector", g_sect)
	} else {
		eprint "Usage:  sector  or  sector sect"
		exit
	}
	gpset _1 g_sect
'
# Display angles availble in various sectors
def sectors '
	if ($# && $# != 3) {
		eprint "Usage:  sectors  or  sectors H K L"
		exit
	}
	if ($#) {
		H = $1; K = $2; L = $3
	}
	ShowSect
	if ($#) {
		get_angles; calcHKL
	}
'
def fpr_freeze() '{
	local   s

	s = ""
	if (g_mode1 == 5)
		return(sprintf("Zone = (%g %g %g) x (%g %g %g)  Qaz = %g  ",\
			g_zh0,g_zk0,g_zl0,g_zh1,g_zk1,g_zl1, F_QAZ))

	if (g_mode1 == 1) s = s sprintf("Delta = %g  ", F_DEL)
	else if (g_mode1 == 2) s = s sprintf("Nu = %g  ", F_NU)
	else if (g_mode1 == 3) s = s sprintf("Qaz = %g  ", F_QAZ)
	else if (g_mode1 == 4) s = s sprintf("Naz = %g  ", F_NAZ)

	if (g_mode2 == 2) s = s sprintf("Alpha = %g  ", F_ALPHA)
	else if (g_mode2 == 3) s = s sprintf("Beta = %g  ", F_BETA)
	else if (g_mode2 == 4) s = s sprintf("Psi = %g  ", F_PSI)

	if (g_mode3 == 1) s = s sprintf("Eta = %g  ", F_ETA)
	else if (g_mode3 == 2) s = s sprintf("Mu = %g  ", F_MU)
	else if (g_mode3 == 3) s = s sprintf("Chi = %g  ", F_CHI)
	else if (g_mode3 == 4) s = s sprintf("Phi = %g  ", F_PHI)

	if (g_mode1 == 0 || g_mode2 == 0) {
		if (g_mode4 == 1) s = s sprintf("Eta = %g  ", F_ETA)
		else if (g_mode4 == 2) s = s sprintf("Mu = %g  ", F_MU)
		else if (g_mode4 == 3) s = s sprintf("Chi = %g  ", F_CHI)
		else if (g_mode4 == 4) s = s sprintf("Phi = %g  ", F_PHI)
	}
	if (g_mode1 == 0 && g_mode2 == 0) {
		if (g_mode5 == 1) s = s sprintf("Eta = %g  ", F_ETA)
		else if (g_mode5 == 2) s = s sprintf("Mu = %g  ", F_MU)
		else if (g_mode5 == 3) s = s sprintf("Chi = %g  ", F_CHI)
		else if (g_mode5 == 4) s = s sprintf("Phi = %g  ", F_PHI)
	}
	if (g_mode2 == 0 && g_mode3 == 0 && g_mode4 == 0)
		s = s sprintf("Omega = %g ", F_OMEGA)

	return(s)
}'
def fpr_mode() '{
	local   s

	if (g_mode1 == 5)
		return("Zone with Qaz-fixed")

	if (g_mode1 == 1) s = s "Delta-fixed "
	else if (g_mode1 == 2) s = s "Nu-fixed "
	else if (g_mode1 == 3) s = s "Qaz-fixed "
	else if (g_mode1 == 4) s = s "Naz-fixed "

	if (g_mode2 == 1) s = s "Alpha=Beta "
	else if (g_mode2 == 2) s = s "Alpha-fixed "
	else if (g_mode2 == 3) s = s "Beta-fixed "
	else if (g_mode2 == 4) s = s "Psi-fixed "

	if (g_mode3 == 1) s = s "Eta-fixed "
	else if (g_mode3 == 2) s = s "Mu-fixed "
	else if (g_mode3 == 3) s = s "Chi-fixed "
	else if (g_mode3 == 4) s = s "Phi-fixed "
	else if (g_mode3 == 5) s = s "Eta=Del/2 "
	else if (g_mode3 == 6) s = s "Mu=Nu/2 "

	if (g_mode1 == 0 || g_mode2 == 0) {
		if (g_mode4 == 1) s = s "Eta-fixed "
		else if (g_mode4 == 2) s = s "Mu-fixed "
		else if (g_mode4 == 3) s = s "Chi-fixed "
		else if (g_mode4 == 4) s = s "Phi-fixed "
	}
	if (g_mode1 == 0 && g_mode2 == 0) {
		if (g_mode5 == 1) s = s "Eta-fixed "
		else if (g_mode5 == 2) s = s "Mu-fixed "
		else if (g_mode5 == 3) s = s "Chi-fixed "
		else if (g_mode5 == 4) s = s "Phi-fixed "
	}
	if (g_mode2 == 0 && g_mode3 == 0 && g_mode4 == 0)
		s = s "Omega-fixed "

	return(s)
}'
# list geometry parameters
def pa '
	onp
	printf("\nPsi-Circle Geometry\n\n")
	printf("  Current mode:  %s (%s)\n", fpr_mode(), fcurmode())

	if (g_frz)
		printf(" Frozen values:  %s\n", fpr_freeze())
	else
		printf(" (Not using frozen angles)\n")
	printf("Current sector:  %s\n", fsect())

	print
	pa_ub
	printf("  Azimuthal Reference:\n")
	if (g_sigtau) {
		printf("               sigma tau = %.5g %.5g\n", \
						SIGMA_AZ, TAU_AZ)
		printf("                  (H K L = %.5g %.5g %.5g)\n\n", \
						g_haz,g_kaz,g_laz)
	} else {
		printf("                   H K L = %.5g %.5g %.5g\n", \
						g_haz,g_kaz,g_laz)
		printf("              (sigma tau = %.5g %.5g)\n\n", \
						SIGMA_AZ, TAU_AZ)
	}
	pa_mono
	printf("                  Lambda = %g \n", LAMBDA)
	printf("\n Cut Points:\n%s\n", fcuts())
	offp
'
def startgeo '
	printf("\n(setmode)")
	setmode
	printf("\n(sector)")
	sector
	printf("\n(setlat)")
	setlat
	if (is_kappa) {
		printf("\n(setkappa)")
		setkappa
	}
	if (g_sigtau) {
		printf("\n(sigtau)")
		sigtau
	} else {
		printf("\n(setaz)")
		setaz
	}
'
def setkappa '
	if ($# == 1) {
		_1 = $1
	} else if ($# == 0) {
		_1 = getval("\nKappa tilt angle (in degrees)", g_kappa)
	} else {
	     eprint "Usage:  setkappa [kappa_tilt]"
	     exit
	}
	gpset _1 g_kappa
'
def savegeo '
	printf("H=%g\n",H)
	printf("K=%g\n",K)
	printf("L=%g\n",L)
	printf("LAMBDA=%g\n",LAMBDA)

	printf("SIGMA_AZ=%g\n",SIGMA_AZ)
	printf("TAU_AZ=%g\n",TAU_AZ)

	printf("F_ALPHA=%g\n",F_ALPHA)
	printf("F_BETA=%g\n",F_BETA)
	printf("F_OMEGA=%g\n",F_OMEGA)
	printf("F_PSI=%g\n",F_PSI)
	printf("F_NAZ=%g\n",F_NAZ)
	printf("F_QAZ=%g\n",F_QAZ)

	printf("F_DEL=%g\n",F_DEL)
	printf("F_ETA=%g\n",F_ETA)
	printf("F_CHI=%g\n",F_CHI)
	printf("F_PHI=%g\n",F_PHI)
	printf("F_NU=%g\n",F_NU)
	printf("F_MU=%g\n",F_MU)

	printf("F_CHI_Z=%g\n",F_CHI_Z)
	printf("F_PHI_Z=%g\n",F_PHI_Z)

	printf("CUT_DEL=%g\n",CUT_DEL)
	printf("CUT_ETA=%g\n",CUT_ETA)
	printf("CUT_CHI=%g\n",CUT_CHI)
	printf("CUT_PHI=%g\n",CUT_PHI)
	printf("CUT_NU=%g\n",CUT_NU)
	printf("CUT_MU=%g\n",CUT_MU)
	printf("CUT_KETA=%g\n",CUT_KETA)
	printf("CUT_KAP=%g\n",CUT_KAP)
	printf("CUT_KPHI=%g\n",CUT_KPHI)

	printf("g_kappa=%g\n",g_kappa)
	printf("g_sigtau=%g\n",g_sigtau?1:0)
	printf("g_prefer=%g\n",g_prefer)
	printf("g_mode1=%g\n",g_mode1)
	printf("g_mode2=%g\n",g_mode2)
	printf("g_mode3=%g\n",g_mode3)
	printf("g_mode4=%g\n",g_mode4)
	printf("g_mode5=%g\n",g_mode5)
	printf("g_sect=%g\n",g_sect)
	printf("g_frz=%g\n",g_frz)
	sav_ub
	printf("g_haz=%g\n",g_haz)
	printf("g_kaz=%g\n",g_kaz)
	printf("g_laz=%g\n",g_laz)
	printf("g_zh0=%g\n",g_zh0)
	printf("g_zk0=%g\n",g_zk0)
	printf("g_zl0=%g\n",g_zl0)
	printf("g_zh1=%g\n",g_zh1)
	printf("g_zk1=%g\n",g_zk1)
	printf("g_zl1=%g\n",g_zl1)
	sav_mono
'
# "cz" - calculate zone command
def cz '{
	local a b
	if ($# != 2) {
		eprint "Usage:  cz a b"
		exit
	} 
	a = $1
	b = $2
	H = a * g_zh0 + b * g_zh1
	K = a * g_zk0 + b * g_zk1
	L = a * g_zl0 + b * g_zl1
	ca H K L
}'
# "mz" - move zone command
def mz '{
	local a b
	if ($# != 2) {
		eprint "Usage:  mz a b"
		exit
	} 
	a = $1
	b = $2
	H = a * g_zh0 + b * g_zh1
	K = a * g_zk0 + b * g_zk1
	L = a * g_zl0 + b * g_zl1
	_br H K L
}'
# "sz" - set zone command
def sz '{
	if ($# == 6) {
		_1 = $1
		_2 = $2
		_3 = $3
		_4 = $4
		_5 = $5
		_6 = $6
	} else if ($# == 0) {
		print "\nEnter zone vectors:"
		_1 = getval(" Zone vec 0 H", g_zh0)
		_2 = getval(" Zone vec 0 K", g_zk0)
		_3 = getval(" Zone vec 0 L", g_zl0)
		_4 = getval(" Zone vec 1 H", g_zh1)
		_5 = getval(" Zone vec 1 K", g_zk1)
		_6 = getval(" Zone vec 1 L", g_zl1)
	} else {
		eprint "Usage:  sz [h0 k0 l0  h1 k1 l1]"
		exit
	} 
	gpset _1 g_zh0
	gpset _2 g_zk0
	gpset _3 g_zl0
	gpset _4 g_zh1
	gpset _5 g_zk1
	gpset _6 g_zl1
}'
# Macro function to display cut points
def fcuts() '{
	local   t

	t = "      del  eta"
	if (!is_s2d2)
		t = t "  chi  phi"
	t = t "   nu   mu"
	if (is_kappa)
		t = t sprintf(" keta  kap khpi")
	t = t sprintf("\n     %4g %4g", CUT_DEL,CUT_ETA)
	if (!is_s2d2)
		t = t sprintf(" %4g %4g", CUT_CHI,CUT_PHI)
	t = t sprintf(" %4g %4g", CUT_NU,CUT_MU)
	if (is_kappa)
		t = t sprintf(" %4g %4g %4g", CUT_KETA,CUT_KAP,CUT_KPHI)
	return(t)
}'
# Macros to set cut points
def cuts '{
	_1 = CUT_DEL
	_2 = CUT_ETA
	_3 = CUT_CHI
	_4 = CUT_PHI
	_5 = CUT_NU
	_6 = CUT_MU
	_7 = CUT_KETA
	_8 = CUT_KAP
	_9 = CUT_KPHI

	if (is_kappa && $# == 9 || !is_kappa && $# == 6 || is_s2d2 && $# == 4) {
		_1 = $1
		_2 = $2
		if (is_s2d2) {
			_5 = $3
			_6 = $4
		} else {
			_3 = $3
			_4 = $4
			_5 = $5
			_6 = $6
			if (is_kappa) {
				_7 = $7
				_8 = $8
				_9 = $9
			}
		}
	} else if ($# == 2) {
		if ("$1" == "del")
			_1 = $2
		else if ("$1" == "eta")
			_2 = $2
		else if ("$1" == "chi")
			_3 = $2
		else if ("$1" == "phi")
			_4 = $2
		else if ("$1" == "nu")
			_5 = $2
		else if ("$1" == "mu")
			_6 = $2
		else if ("$1" == "keta")
			_7 = $2
		else if ("$1" == "kap")
			_8 = $2
		else if ("$1" == "kphi")
			_9 = $2
		else {
			eprint "No cut point for angle " "$1"
			exit
		}
	} else if ($# == 0) {
		print "\n\
Enter cut point x for each angle.  Motion of that\n\
circle is restricted to x and x+360.  Thus, if cut\n\
point is -180, circle will go long way around to\n\
travel from -175 to +175.\n"
		_1 = getval("\nCut for del", CUT_DEL)
		_2 = getval("Cut for eta", CUT_ETA)
		if (!is_s2d2) {
			_3 = getval("Cut for chi", CUT_CHI)
			_4 = getval("Cut for phi", CUT_PHI)
		}
		_5 = getval("Cut for nu", CUT_NU )
		_6 = getval("Cut for mu", CUT_MU )
		if (is_kappa) {
			_7 = getval("Cut for keta", CUT_KETA)
			_8 = getval("Cut for kap", CUT_KAP)
			_9 = getval("Cut for kphi", CUT_KPHI)
		}
	} else {
		eprintf("Usage:  cuts [angle cut]|[(all %d cuts)]\n",\
				     is_kappa? 9:(is_s2d2? 4:6))
		exit
	}
	gpset _1 CUT_DEL
	gpset _2 CUT_ETA
	if (!is2d2) {
		gpset _3 CUT_CHI
		gpset _4 CUT_PHI
	}
	gpset _5 CUT_NU
	gpset _6 CUT_MU
	if (is_kappa) {
		gpset _7 CUT_KETA
		gpset _8 CUT_KAP
		gpset _9 CUT_KPHI
	}
	printf("\nCurrent cuts:\n%s\n", fcuts())
}'

# Coordinate names
def H         'Q[0]'
def K         'Q[1]'
def L         'Q[2]'
def LAMBDA    'Q[3]'

def ALPHA     'Q[4]'
def BETA      'Q[5]'
def OMEGA     'Q[6]'
def TTH       'Q[7]'
def PSI       'Q[8]'
def TAU       'Q[9]'
def QAZ       'Q[10]'
def NAZ       'Q[11]'
def SIGMA_AZ  'Q[12]'
def TAU_AZ    'Q[13]'

def F_ALPHA   'Q[14]'    # Frozen values
def F_BETA    'Q[15]'
def F_OMEGA   'Q[16]'
def F_PSI     'Q[17]'
def F_NAZ     'Q[18]'
def F_QAZ     'Q[19]'

def F_DEL     'Q[20]'
def F_ETA     'Q[21]'
def F_CHI     'Q[22]'
def F_PHI     'Q[23]'
def F_NU      'Q[24]'
def F_MU      'Q[25]'

def F_CHI_Z   'Q[26]'
def F_PHI_Z   'Q[27]'

def CUT_DEL   'Q[28]'   # cut points
def CUT_ETA   'Q[29]'
def CUT_CHI   'Q[30]'
def CUT_PHI   'Q[31]'
def CUT_NU    'Q[32]'
def CUT_MU    'Q[33]'
def CUT_KETA  'Q[34]'
def CUT_KAP   'Q[35]'
def CUT_KPHI  'Q[36]'

def AZIMUTH   'PSI'
def F_AZIMUTH 'F_PSI'

# Calc calls
def calcA   'calc(1)'
def calcHKL 'calc(2)'
def ShowSect 'calc(3, $1)'
def calcP_fromR 'calc(8, 0)'    # find pseudo from real motors
def calcR_fromP 'calc(8, 1)'    # find real from pseudo motors

# Geometry parameters
def g_prefer 'G[0]'     # sector preference scheme
def g_sect   'G[1]'     # sector
def g_frz    'G[2]'     # freeze

def g_haz    'G[3]'     # azimuthal reference
def g_kaz    'G[4]'
def g_laz    'G[5]'

def g_zh0    'G[6]'     # zone vec 0
def g_zk0    'G[7]'
def g_zl0    'G[8]'
def g_zh1    'G[9]'     # zone vec 1
def g_zk1    'G[10]'
def g_zl1    'G[11]'

def g_kappa  'G[12]'    # kappa angle
def g_sigtau 'G[15]'    # set if sig-tau take precdence over azi HKL

def g_mode1  'G[16]'    # spectrometer mode
def g_mode2  'G[17]'    # spectrometer mode
def g_mode3  'G[18]'    # spectrometer mode
def g_mode4  'G[19]'    # spectrometer mode
def g_mode5  'G[20]'    # spectrometer mode


# Set defaults on "fresh" start
if (FRESH) {
	LAMBDA = 1.54

	# Set azimuth
	g_haz=0
	g_kaz=0
	g_laz=1

	# Set cuts
	CUT_DEL=-180
	CUT_ETA=-180
	CUT_CHI=-180
	CUT_PHI=-180
	CUT_NU=-180
	CUT_MU=-180
	CUT_KETA=-180
	CUT_KAP=-180
	CUT_KPHI=-180

	g_mode1 = 1
	g_mode2 = 0
	g_mode3 = 0
}

# Do not remove this line -- it keeps the parser from waiting for an "else".
#++++ install source file:  /home/specadm/spec5.01.01/macros/ub.mac
#
#  @(#)ub.mac	5.2  04/08/01 CSS
#
#  "Spec" Release 5
#
#  Copyright (c) 1991,1992,1993,1995,1997,1998,1999,2001
#  by Certified Scientific Software.
#  All rights reserved.
#  Copyrighted as an unpublished work.
#
#########################################################################
#

# Set lattice parameters
def setlat '{
	local user_ub

	user_ub = USER_UB
	if ($# == 6) {
		_1 = $1; _2 = $2; _3 = $3; _4 = $4; _5 = $5; _6 = $6
	} else if ($# == 0) {
		print "\nEnter real space lattice parameters:"
		_1 = getval(" Lattice a", g_aa)
		_2 = getval(" Lattice b", g_bb)
		_3 = getval(" Lattice c", g_cc)
		_4 = getval(" Lattice alpha", g_al)
		_5 = getval(" Lattice beta", g_be)
		_6 = getval(" Lattice gamma", g_ga)
	} else {
		print "Usage:  setlat  or  setlat a b c alpha beta gamma"
		exit
	}
	gpset _1 g_aa
	gpset _2 g_bb
	gpset _3 g_cc
	gpset _4 g_al
	gpset _5 g_be
	gpset _6 g_ga
	calcR
	if (!user_ub)
		calcG
}'
# Set reciprocal lattice parameters
def setrlat '{
	local user_ub

	user_ub = USER_UB
	if ($# == 6) {
		_1 = $1; _2 = $2; _3 = $3; _4 = $4; _5 = $5; _6 = $6
	} else if ($# == 0) {
		print "\nEnter reciprocal space lattice parameters:"
		_1 = getval(" Lattice a_star", g_aa_s)
		_2 = getval(" Lattice b_star", g_bb_s)
		_3 = getval(" Lattice c_star", g_cc_s)
		_4 = getval(" Lattice alpha_star", g_al_s)
		_5 = getval(" Lattice beta_star", g_be_s)
		_6 = getval(" Lattice gamma_star", g_ga_s)
	} else {
		print \
	     "Usage:  setrlat  or  setrlat a_* b_* c_* alpha_* beta_* gamma_*"
		exit
	}
	gpset _1 g_aa_s
	gpset _2 g_bb_s
	gpset _3 g_cc_s
	gpset _4 g_al_s
	gpset _5 g_be_s
	gpset _6 g_ga_s
	calcD
	if (!user_ub)
		calcG
}'
def pa_ub '
	{
	  local i s t u

	  printf("  Primary Reflection (at lambda %g):\n", g_lambda0)
	  for (i=0, s=t=u=""; i<_numgeo; i++) {
		s=sprintf("%s%s ", s, motor_mne(mA[i]))
		t=sprintf("%s%g ", t, U[18+i])  # g_u00 ...
		u=sprintf("%s%g ", u, U[24+i])  # g_u10 ...
	  }
	  printf("%25s= %s\n", s, t)
	  printf("                   H K L = %g %g %g\n\n", g_h0,g_k0,g_l0)
	  printf("  Secondary Reflection (at lambda %g):\n", g_lambda1)
	  printf("%25s= %s\n", s, u)
	  printf("                   H K L = %g %g %g\n\n", g_h1,g_k1,g_l1)
	}
	printf("  Lattice Constants (lengths / angles):\n")
	printf("              real space = %.4g %.4g %.4g / %.4g %.4g %.4g\n", \
				g_aa,g_bb,g_cc, g_al,g_be,g_ga)
	printf("        reciprocal space = %.4g %.4g %.4g / %.4g %.4g %.4g\n\n", \
				g_aa_s,g_bb_s,g_cc_s, g_al_s,g_be_s,g_ga_s)

'
def sav_ub '
	printf("g_aa=%g\n",g_aa)
	printf("g_bb=%g\n",g_bb)
	printf("g_cc=%g\n",g_cc)
	printf("g_al=%g\n",g_al)
	printf("g_be=%g\n",g_be)
	printf("g_ga=%g\n",g_ga)

	printf("g_aa_s=%g\n",g_aa_s)
	printf("g_bb_s=%g\n",g_bb_s)
	printf("g_cc_s=%g\n",g_cc_s)
	printf("g_al_s=%g\n",g_al_s)
	printf("g_be_s=%g\n",g_be_s)
	printf("g_ga_s=%g\n",g_ga_s)

	printf("g_u00=%g\n",g_u00)
	printf("g_u01=%g\n",g_u01)
	printf("g_u02=%g\n",g_u02)
	if (_numgeo > 3)
		printf("g_u03=%g\n",g_u03)
	if (_numgeo > 4)
		printf("g_u04=%g\n",g_u04)
	if (_numgeo > 5)
		printf("g_u05=%g\n",g_u05)

	printf("g_u10=%g\n",g_u10)
	printf("g_u11=%g\n",g_u11)
	printf("g_u12=%g\n",g_u12)
	if (_numgeo > 3)
		printf("g_u13=%g\n",g_u13)
	if (_numgeo > 4)
		printf("g_u14=%g\n",g_u14)
	if (_numgeo > 5)
		printf("g_u15=%g\n",g_u15)

	printf("g_h0=%g\n",g_h0)
	printf("g_k0=%g\n",g_k0)
	printf("g_l0=%g\n",g_l0)
	printf("g_h1=%g\n",g_h1)
	printf("g_k1=%g\n",g_k1)
	printf("g_l1=%g\n",g_l1)

	printf("g_lambda0=%g\n", g_lambda0)
	printf("g_lambda1=%g\n", g_lambda1)

	if (USER_UB)
		for(i=0;i<9;i++) printf("UB[%d]=%.15g\n",i,UB[i])
	else
		printf("calcG\n")
'
# Prints the UB matrix on the screen
def showUB '{
	printf("Orientation Matrix by Row:\n\n")
	printf("Row 1: %10.5f %10.5f %10.5f\n",UB[0],UB[3],UB[6])
	printf("Row 2: %10.5f %10.5f %10.5f\n",UB[1],UB[4],UB[7])
	printf("Row 3: %10.5f %10.5f %10.5f\n",UB[2],UB[5],UB[8])
}'

# Asks user to enter the Orientation matrix in the UB array
def enterUB '{
	local x
	print "Enter Orientation Matrix by Rows:"
	x = getval(" Row 1:",sprintf("%f %f %f",UB[0],UB[3],UB[6]))
	sscanf(x,"%f %f %f",UB[0],UB[3],UB[6])
	x = getval(" Row 2:",sprintf("%f %f %f",UB[1],UB[4],UB[7]))
	sscanf(x,"%f %f %f",UB[1],UB[4],UB[7])
	x = getval(" Row 3:",sprintf("%f %f %f",UB[2],UB[5],UB[8]))
	sscanf(x,"%f %f %f",UB[2],UB[5],UB[8])
}'

def or_swap '{
	local i t
	comment "Orientation vectors swapped"
	for (i=0;i<_numgeo;i++) {
		# g_u00 ... g_u10 ...
		t = U[18+i]; U[18+i] = U[24+i]; U[24+i] = t
	}
	for (i=0;i<3;i++) {
		# g_h0 ... g_h1 ...
		t = U[12+i]; U[12+i] = U[15+i]; U[15+i] = t
	}
	t = g_lambda0; g_lambda0 = g_lambda1; g_lambda1 = t
	calcG
}'

# set orientation matrix primary reflection
def or0 '
	if ($# == 3) {
		_1 = $1; _2 = $2; _3 = $3
	} else if ($# == 0) {
		print "\nEnter primary-reflection HKL coordinates:"
		_1 = getval(" H", g_h0)
		_2 = getval(" K", g_k0)
		_3 = getval(" L", g_l0)
	} else {
		print "Usage:  or0  or  or0 H K L"
		exit
	}
	waitmove; get_angles
	gpset _1       g_h0
	gpset _2       g_k0
	gpset _3       g_l0
	gpset A[mA[0]] g_u00
	gpset A[mA[1]] g_u01
	gpset A[mA[2]] g_u02
	if (_numgeo > 3) { gpset A[mA[3]] g_u03 }
	if (_numgeo > 4) { gpset A[mA[4]] g_u04 }
	if (_numgeo > 5) { gpset A[mA[5]] g_u05 }
	gpset LAMBDA g_lambda0
	calcG
'
def setor0 '{
	print "\nEnter primary-reflection angles:"
	_4 = getval(sprintf(" %s", motor_name(mA[0])), g_u00)
	_5 = getval(sprintf(" %s", motor_name(mA[1])), g_u01)
	_6 = getval(sprintf(" %s", motor_name(mA[2])), g_u02)
	if (_numgeo > 3)
		_7 = getval(sprintf(" %s", motor_name(mA[3])), g_u03)
	if (_numgeo > 4)
		_8 = getval(sprintf(" %s", motor_name(mA[4])), g_u04)
	if (_numgeo > 5)
		_9 = getval(sprintf(" %s", motor_name(mA[5])), g_u05)
	print "\nEnter primary-reflection HKL coordinates:"
	_1 = getval(" H", g_h0)
	_2 = getval(" K", g_k0)
	_3 = getval(" L", g_l0)
	gpset _1 g_h0
	gpset _2 g_k0
	gpset _3 g_l0
	gpset _4 g_u00
	gpset _5 g_u01
	gpset _6 g_u02
	if (_numgeo > 3) { gpset _7 g_u03 }
	if (_numgeo > 4) { gpset _8 g_u04 }
	if (_numgeo > 5) { gpset _9 g_u05 }
	gpset LAMBDA g_lambda0
	calcG
}'

# set orientation matrix secondary reflection
def or1 '
	if ($# == 3) {
		_1 = $1; _2 = $2; _3 = $3
	} else if ($# == 0) {
		print "\nEnter secondary-reflection HKL coordinates:"
		_1 = getval(" H", g_h1)
		_2 = getval(" K", g_k1)
		_3 = getval(" L", g_l1)
	} else {
		print "Usage:  or1  or  or1 H K L"
		exit
	}
	waitmove; get_angles
	gpset _1       g_h1
	gpset _2       g_k1
	gpset _3       g_l1
	gpset A[mA[0]] g_u10
	gpset A[mA[1]] g_u11
	gpset A[mA[2]] g_u12
	if (_numgeo > 3) { gpset A[mA[3]] g_u13 }
	if (_numgeo > 4) { gpset A[mA[4]] g_u14 }
	if (_numgeo > 5) { gpset A[mA[5]] g_u15 }
	gpset LAMBDA g_lambda1
	calcG
'
def setor1 '{
	print "\nEnter secondary-reflection angles:"
	_4 = getval(sprintf(" %s", motor_name(mA[0])), g_u10)
	_5 = getval(sprintf(" %s", motor_name(mA[1])), g_u11)
	_6 = getval(sprintf(" %s", motor_name(mA[2])), g_u12)
	if (_numgeo > 3)
		_7 = getval(sprintf(" %s", motor_name(mA[3])), g_u13)
	if (_numgeo > 4)
		_8 = getval(sprintf(" %s", motor_name(mA[4])), g_u14)
	if (_numgeo > 5)
		_9 = getval(sprintf(" %s", motor_name(mA[5])), g_u15)
	print "\nEnter secondary-reflection HKL coordinates:"
	_1 = getval(" H", g_h1)
	_2 = getval(" K", g_k1)
	_3 = getval(" L", g_l1)
	gpset _1 g_h1
	gpset _2 g_k1
	gpset _3 g_l1
	gpset _4 g_u10
	gpset _5 g_u11
	gpset _6 g_u12
	if (_numgeo > 3) { gpset _7 g_u13 }
	if (_numgeo > 4) { gpset _8 g_u14 }
	if (_numgeo > 5) { gpset _9 g_u15 }
	gpset LAMBDA g_lambda1
	calcG
}'

# Macros for fitting UB using a series of reflections
# "REFLEX" holds the name of the file to be used to store the reflection data
#
global REFLEX
def reflex_beg '{
	if ("$1" == "0") {
		if (REFLEX == "")
			REFLEX = "reflex"
		REFLEX = getsval("Reflections file", REFLEX)
	} else
		REFLEX = "$1"

	if (open(REFLEX))
		exit
	close(REFLEX)
	if (file_info(REFLEX, "-s"))
		unix(sprintf("mv %s %s.bak", REFLEX, REFLEX))
	fprintf(REFLEX,"# %s\n\n_begUB\n\n",date())
}'
def reflex_end '
	fprintf(REFLEX,"_fitUB\n")
	printf("Type \"qdo %s\" to calculate new orientation matrix.\n",REFLEX)
'
def reflex '
	if ($# != 3) {
		print "Usage:  reflex H K L"
		exit
	}
	if (REFLEX == "") {
		REFLEX = getsval("Reflections file", "reflex")
		if (REFLEX == "")
			exit
	}
	waitmove; get_angles; calcHKL
	fprintf(REFLEX,"H = %g;  K = %g;  L = %g\n",$1,$2,$3)
	{
	  local i

	  for (i=0; i<_numgeo; i++)
		fprintf(REFLEX,"A[%s]=%9.4f;  ",motor_mne(mA[i]),A[mA[i]])
	  fprintf(REFLEX,"\n")
	}
	fprintf(REFLEX,"# counts = %g\n", S[DET])
	fprintf(REFLEX,"_addUB\n\n")
'

def calcG       'calc(4)'
def USER_UB     'calc(4,1)'
def calcL       'calc(13)'  # calculate lattice parameters from UB
def calcD       'calc(7,0)' # calculate direct from recip lattice params
def calcR       'calc(7,1)' # calculate recip from direct lattice params
def _begUB      'calc(10)'  # initialize sums for fitting UB
def _addUB      'calc(11)'  # add a reflection to fitting sums
def _fitUB      'calc(12)'  # fit UB

def g_aa        'U[0]'  # a lattice constant (real space)
def g_bb        'U[1]'  # b lattice constant (real space)
def g_cc        'U[2]'  # c lattice constant (real space)
def g_al        'U[3]'  # alpha lattice angle (real space)
def g_be        'U[4]'  # beta  lattice angle (real space)
def g_ga        'U[5]'  # gamma lattice angle (real space)

def g_aa_s      'U[6]'  # a lattice constant (reciprocal space)
def g_bb_s      'U[7]'  # b lattice constant (reciprocal space)
def g_cc_s      'U[8]'  # c lattice constant (reciprocal space)
def g_al_s      'U[9]'  # alpha lattice angle (reciprocal space)
def g_be_s      'U[10]' # beta  lattice angle (reciprocal space)
def g_ga_s      'U[11]' # gamma lattice angle (reciprocal space)

def g_h0        'U[12]' # H of primary reflection
def g_k0        'U[13]' # K of primary reflection
def g_l0        'U[14]' # L of primary reflection
def g_h1        'U[15]' # H of secondary reflection
def g_k1        'U[16]' # K of secondary reflection
def g_l1        'U[17]' # L of secondary reflection

def g_u00       'U[18]' # angles of primary reflection
def g_u01       'U[19]'
def g_u02       'U[20]'
def g_u03       'U[21]'
def g_u04       'U[22]'
def g_u05       'U[23]'

def g_u10       'U[24]' # angles of secondary reflection
def g_u11       'U[25]'
def g_u12       'U[26]'
def g_u13       'U[27]'
def g_u14       'U[28]'
def g_u15       'U[29]'

def g_lambda0   'U[30]' # lambda when or0 was set
def g_lambda1   'U[31]' # lambda when or1 was set

# geo_ub_default can have content added for particular geometries
cdef("geo_ub_default", "", "ub.mac")

# Set defaults on "fresh" start
if (FRESH) {
	printf("Warning:  Using default lattice constants.\n")
	# Set some default lattice constants
	g_aa=g_bb=g_cc=1.54
	g_al=g_be=g_ga=90
	# Set some default orientation reflections
	g_u00=60
	g_u01=30
	g_u02=0
	g_u03=0
	g_u04=0
	g_u05=0
	g_h0=1
	g_k0=0
	g_l0=0
	g_u10=60
	g_u11=30
	g_u12=0
	if ((whatis("g_config")&0xFF) == 2 && g_config == 0)
		g_u13=90
	else
		g_u13=-90
	g_u14=0
	g_u15=0
	g_h1=0
	g_k1=1
	g_l1=0
	g_lambda0=g_lambda1=1.54
	geo_ub_default
	calcG
	print
}

calcR
