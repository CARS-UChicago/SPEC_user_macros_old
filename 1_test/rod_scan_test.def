### Global variable used by these macros
global RS_SCALE_BY
       RS_SCALE_BY = 1;
      # RS_SCALE_BY = 0; # just use max_cnt time for all
      # RS_SCALE_BY = 1; # use sqrt(F)
      # RS_SCALE_BY = 2; # use 1/F    
global RS_CHECK_SCAN
       RS_CHECK_SCAN = 1;
global RS_SKIP_BRAGGS
       RS_SKIP_BRAGGS = 1;
global RS_MAX_REP
       RS_MAX_REP = 5;
global RS_TEST
       RS_TEST = 1;
global RS_PLOT_AVE
       RS_PLOT_AVE = 0;
global RS_SCAN_TITLE



# Note _ascan calls scan_data which builds the SCAN_D array...
# SCAN_D[pnt][0] = x-value
# SCAN_D[pnt][1] = sec
# SCAN_D[pnt][2] = io
#      etc.. 
# SCAN_D always(??) has all the scalars in thier usual order
# therefore, DET + 1 should also be the right col for data averaging 
# and MON + 1 to normalize the data (MON < 0 means its shut off)
# see the plotselect and counters macros 
#

# Note if doing Traj_scans should check that the fastest rocking scan
# wont exceed the limits ....

####################################################################
# Rod_scan.
def test_scan '{
    # local vars for input data
    local h_val, k_val, l_st, l_en, del_l 
    local max_cnt, l_b, del_lb 

    # local vars for scan calcs, etc...    
    local num_l_pts,I_scale, del_sign  


    # local vars for rocking scan
    local scan_range, num_scan_pts, max_cnt, max_rep, num_rep 
      scan_range =  1;
      num_scan_pts = 40;
      min_cnt = 1;  # min cnt time is 1/2 sec per point
      max_rep = RS_MAX_REP;
    

    # other misc local vars
    local msg_str, j, temp_val, l_val, exec 
    
   
    # check input
    if ($# != 9 ) {
      msg_str = "Usage: rod_scan H K L_start L_end del_L" 
      msg_str = msg_str " Scan_Axis Max_count L_bragg Delta_Lbragg\n "
      print msg_str
      exit
    } 
    # This makes sure the scan-axis exists 
    _check0 $6


    # assign input data to local vars
    h_val = $1  
    k_val = $2 
    l_st = $3 
    l_en = $4 
    del_l = $5 
    scan_axis = $6 
    max_cnt = $7 
    l_b = $8 
    del_lb = $9

    num_l_pts = int( (l_en - l_st)/del_l );
    del_sign = sign(num_l_pts)
    num_l_pts = 1 + (  del_sign * num_l_pts) ;
    if (num_l_pts == 1) {
        msg_str = " Error: Num points = 1 "
        print msg_str
        exit
    }
    
    # build an array for the rocking scan data
    local double array RS_ARRAY[num_l_pts][6]

    ## Make an array of HKL, cnt_times, F-values and bragg flags 
    #   RS_ARRAY[j][0] = H;
    #   RS_ARRAY[j][1] = K;
    #   RS_ARRAY[j][2] = L;
    #   RS_ARRAY[j][3] = count_time;
    #   RS_ARRAY[j][4] = I;
    #   RS_ARRAY[j][5] = bragg_flag;
    #

    I_scale = 1e3;  
    for (j=0;j<num_l_pts;j++) {
       bragg_flag = 0;
       RS_ARRAY[j][0] = h_val;
       RS_ARRAY[j][1] = k_val;
       RS_ARRAY[j][2] = l_val = l_st + (j)*(del_l)*(del_sign);
       RS_ARRAY[j][3] = min_cnt;
      
       temp_val = square( sin( PI*(l_val - l_b ) / del_lb ) ); 
       if (temp_val < 1/I_scale) {
             RS_ARRAY[j][4] = I_scale;
             RS_ARRAY[j][5] = 1;
       } else {
             RS_ARRAY[j][4] = (1/temp_val)/I_scale;
             RS_ARRAY[j][5] = 0;
       }  
    }

   ## Now scale the cnt times by sqrt(1/I) or 1/I or nothing
    for (j=0;j<num_l_pts;j++) {
      if(RS_SCALE_BY == 0){
          RS_ARRAY[j][3]   = int( max_cnt );
      } else if(RS_SCALE_BY == 1){
         RS_ARRAY[j][3]   = int( RS_ARRAY[j][3] * sqrt( 1 / RS_ARRAY[j][4] ) );
      } else {
          RS_ARRAY[j][3]   = int( RS_ARRAY[j][3] * 1 / RS_ARRAY[j][4] );
      }
      if (RS_ARRAY[j][3]   >  max_cnt) RS_ARRAY[j][3] = max_cnt;
      if (RS_ARRAY[j][3]   <  min_cnt) RS_ARRAY[j][3] = min_cnt;
    }

 
   ## Do pre checking on the HKL range, 
   # ie can we get to all these places
#   for (j=0;j<num_l_pts;j++) {
#       H = RS_ARRAY[j][0]; 
#       K = RS_ARRAY[j][1]; 
#       L = RS_ARRAY[j][2];
#       if (calcA){
#          eprintf("(H K L = %g %g %g)\n",H,K,L)
#          exit
#       }
#       _bad_lim=0; _hkl_lim
#       if (_bad_lim) {
#          eprintf("(H K L = %g %g %g)\n",H,K,L)
#          exit
#      }
#   }

   
  # Print message that starting a new rod scan
    msg_str = sprintf("%s %g %g","#ROD_SCAN rod_scan", h_val, k_val);
    msg_str = sprintf("%s %g %g %g",msg_str, l_st,l_en,del_l);
    msg_str = sprintf("%s %s %g %g %g", msg_str, motor_mne(scan_axis), max_cnt, l_b, del_lb); 
    printf("\n%s\n", msg_str); 

## scan loop
# do the scan
# create arrays to hold the data for the scans
# ie shouldnt have to worry about old data still in there ... 
local double array RS_X_ARRAY[num_scan_pts+1][max_rep];
local double array RS_Y_ARRAY[num_scan_pts+1][max_rep];
local double array SCAN_INFO[max_rep][9];
local double array bad[max_rep];

######### Do the scans ##########
if (RS_CHECK_SCAN == 0) {
       # make sure the A array is updated with current values
       get_angles;    

       if (DATAFILE !=""){
              fprintf(DATAFILE,"\n%s\n", msg_str); 
       }
       
       ####### start L loop ############# 
       for (j=0;j<num_l_pts;j++) {
           # clear data arrays
           RS_X_ARRAY = 0;
           RS_Y_ARRAY = 0;
           SCAN_INFO = 0;
           bad = 0;

           # get HKL and cnt time for the scan
           H = RS_ARRAY[j][0]; 
           K = RS_ARRAY[j][1]; 
           L = RS_ARRAY[j][2];
           scan_cnt_time = RS_ARRAY[j][3];

           RS_SCAN_TITLE = sprintf("#RS H = %g , K = %g , L = %g",H,K,L);

           ## if its a bragg skip it
           if ( (RS_ARRAY[j][5] == 1) && (RS_SKIP_BRAGGS == 1) ) {
              printf("%s\n",RS_SCAN_TITLE);
              msg_str = sprintf("#Skip L = %g, Bragg Peak", L);
              printf("%s\n",msg_str);
           } else {
           ## do the scan
              printf("%s\n",RS_SCAN_TITLE);
              local s, e, n, ti
              s =  -1*scan_range/2
              e = scan_range/2
              n = num_scan_pts
              ti = scan_cnt_time

              ### keep doing the scan untill its good enough or hit max repeat ...
              num_rep = 0;
              exec = 1;
              while( (exec==1) && (num_rep<max_rep) ) { 
                   # note put the RS_SCAN_TITLE and num_rep + 1 into the Fheader macro ...
                   # test with fake scans
                   if (RS_TEST) {
                      # fake_br H K L 
                      # waitmove
                      # fake_dscan $6 s e n ti 1e4*RS_ARRAY[j][4] 10 .1
                      for (j=0;j<n+1;j++){
                         SCAN_D[j][0]=j;
                         SCAN_D[j][1]=1;
                         SCAN_D[j][2]=1e6;
                         SCAN_D[j][3]=1e6;
                         SCAN_D[j][4]=100*exp(-square(j-n/2)/(n/4));
                      }
                   # or do the real scan
                   } else {
                      # br H K L 
                      # waitmove
                      # dscan $6 s e n ti  
                   }
  
                   # load the data from this scan into an array for averaging
                   # and analyzing ......
                   RS_X_ARRAY[0:n][num_rep] = SCAN_D[0:n][0];
                   if(MON < 0){
                      RS_Y_ARRAY[0:n][num_rep] = SCAN_D[0:n][DET+1];
                   } else {
                      RS_Y_ARRAY[0:n][num_rep] = SCAN_D[0:n][DET+1]/SCAN_D[0:n][MON+1];
                   }
                   p "here1"
                   # check the data
                   # note the return is a nine element array
                   SCAN_INFO[num_rep][] = RS_ANAL(RS_X_ARRAY, RS_Y_ARRAY, num_rep + 1, bad );
                   p "here3" 
                   bad[num_rep] = SCAN_INFO[num_rep][0];

                   # if its ok move on
                   # if (bad[num_rep] == 0) exec = 0;

                   # here need to print some info about the scan 
                   # ie at leat have to print the value of BAD_SCAN_IDX .....
                    num_rep = num_rep + 1;
                   
              }  
             #### end of while loop on the scan
             # here need to print some info about the avg scan?? .....
           }
       }
       ######### end L loop#########
########## check the scan #############
} else {
       # check out the scan info
       local tot_time;
       tot_time = 0;
       p "test scan info"
       p "       H      K      L     cnt      I      b_flag "
       for (j=0;j<num_l_pts;j++){
           msg_str="";        
           for(k=0;k<6;k++){
            msg_str = sprintf("%s  %6.5g", msg_str, RS_ARRAY[j][k]);
           }
           tot_time = tot_time + RS_ARRAY[j][3]*num_scan_pts;
           msg_str = sprintf("%s \n", msg_str);
           p msg_str;
       }      
       p "Number of points = ", num_l_pts
       p "Estimated total time (sec) = ", tot_time 
       p "Estimated total time (min) = ", tot_time / 60 
       p "Estimated total time (hrs) = ", tot_time / 3600 
      
}
####### end of scan loop

# may want to print a message that its done
# note what happens if cntrl-c outa the scan?

}'

###################################################################################
#
def RS_ANAL( rs_x_array, rs_y_array, rs_nscans, bad_idx_array) '{
        local j, rs_nrows, rs_ncols, n_ave, idx; 

        # The array returned from this function
        # is initialized to all zeros
        # the first value is the reason for exiting
        # see BAD_SCAN_IDX below
        local double array summary_data_array[1][9];
        summary_data_array = 0.0;

        # summary_data_array[][0] --> BAD_SCAN_IDX in the rodscan macro:
        # BAD_SCAN_IDX =  0   is a good scan (or avg is good)
        # BAD_SCAN_IDX =  1   poor stats repeat same scan and avg
        # BAD_SCAN_IDX =  2   detector is saturated, repeat and dont avg
        # BAD_SCAN_IDX =  3   scan is too narrow, repeat wider (? include in average)
        # BAD_SCAN_IDX =  4   scan is too wide, repeat narrower (? include in average)
        # BAD_SCAN_IDX =  5   problem calculating the stats ... dont avg(??)

         
        rs_nrows = array_op("rows",rs_x_array);
        if( rs_nrows != array_op("rows",rs_y_array) ) {
            print "Error array mismatch"
            summary_data_array[0][0] = 5.0;
            return summary_data_array;
        }

        rs_ncols = array_op("cols",rs_x_array);
        if( rs_ncols != array_op("cols",rs_y_array) ) {
            print "Error array mismatch"
            summary_data_array[0][0] = 5.0;
            return summary_data_array;
        }

        # check for saturation
        # note if atten is in may be ok for 
        # cnts in det but i1 will still be > max ?????
        # therefore need to check i1 and det ???
        # if sat return 2

        # check for width vs range ...
        # return 3 or 4
        # here may want to avg the data but will have to 
        # interpolate the data ......
        # note if the number of points in the scan changes then 
        # the data array is all screwed up .....
        # how do you do interpolations for traj scan data ?????


        # average the good data
        local double array AVG_ARRAY[rs_nrows][2];
        AVG_ARRAY = 0.0;
        n_ave = 0;
        for (j=0;j<rs_nscans;j++){
           # note the bad_scan array was initialized to zeros
           # therefore this will include the newest data if the above
           # tests were passed
           if (bad_idx_array[j] < 2){
               AVG_ARRAY[][0] = AVG_ARRAY[][0] + rs_x_array[][j] ;
               AVG_ARRAY[][1] = AVG_ARRAY[][1] + rs_y_array[][j] ;
               n_ave = n_ave + 1;
           }
        }

        if (n_ave ==0) return (summary_data_array);  # this should never happen
        AVG_ARRAY[][0] = AVG_ARRAY[][0] / n_ave;
        AVG_ARRAY[][1] = AVG_ARRAY[][1] / n_ave; 

        # now get some data
        # maybe this is what should get returned....
        # and include the bad_idx with it???
        idx = array_op("rmax",AVG_ARRAY[][1]);
        summary_data_array[0][1] = AVG_ARRAY[idx][1];
        summary_data_array[0][2] = AVG_ARRAY[idx][0];
        summary_data_array[0][3] = array_op("fwhm",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][4] = array_op("cfwhm",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][5] = array_op("lhmx",AVG_ARRAY[][0],AVG_ARRAY[][1]);
        summary_data_array[0][6] = array_op("uhmx",AVG_ARRAY[][0],AVG_ARRAY[][1]);
       # summary_data_array[0][7] = int intensity
       # summary_data_array[0][8] = percent rsd;



        if(RS_PLOT_AVE){
           # initialize the plot and plot the avg data
           RS_INIT_PLOT( rs_nscans, summary_data_array ) 
           array_plot(AVG_ARRAY[][0],AVG_ARRAY[][1])
         
           p "Plotted avg data for nscans = ", rs_nscans  
           # xx = getval("hit any key to cont");
        }
p "here2"
return(summary_data_array);

}'

####################################################################
# this is similiar to the splot macro in standard.mac
def RS_INIT_PLOT( nscans, summary_data ) '{
        local title, y_label, plot_str 

        # set up the plot window to plot the averaged data
        if (PLOT_MODE&128) {
		plot_cntl(sprintf("colors=%s",splot_col))
		plot_cntl("open")
	  }
	  plot_cntl("erase")
	  plot_cntl(PLOT_MODE&8? "xexact":"-xexact")
	  plot_cntl(PLOT_MODE&32? "ylog":"-ylog")
	  plot_cntl(PLOT_MODE&256? "-dots":"dots")
	  plot_cntl(PLOT_MODE&512? "-lines":"lines")
	  plot_cntl(PLOT_MODE&1024? "-ebars":"ebars")

        # plot range
	  plot_range("auto","auto","auto","auto")

        # title, y-axis label, x-axis label
        plot_str = sprintf("%s, Nave = %d", RS_SCAN_TITLE, nscans);
        printf("%s\n",plot_str);
	  plot_move(-50,0,plot_str)

        plot_str = sprintf("Ave(%s/%s)", cnt_mne(DET), cnt_mne(MON));
	  plot_move(0,0,plot_str)

	  plot_move(0,-1,sprintf("%.8s", pl_xl))

        plot_str = sprintf("Y_max = %g, X at Y_max = %g, fwhm = %g, cfwhm = %g", \
                            summary_data[0][1], summary_data[0][2], summary_data[0][3], summary_data[0][4]) 
        printf("%s\n",plot_str);
	  plot_move(10,1,plot_str);

        plot_str = sprintf("lhmx = %g, uhmx = %g, I = %g, prsd = %g", \
                             summary_data[0][5], summary_data[0][6], summary_data[0][7], summary_data[0][8]); 
        printf("%s\n",plot_str);
	  plot_move(10,2,plot_str);

        #plot_move(0,3)

}'
####################################################################
def square(x) '{
    return(x*x)
}'
