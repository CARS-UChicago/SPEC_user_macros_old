##################################################################################
# keta_mesh_scan ---> do keta scans as at different H at fixed alpha and Qz (L)
# glass_or   ----> define orientation matrix for film on glass surface
# get_user_lim
def keta_mesh_scan '{

    # check input
    if ($# != 9 ) {
      #                            		1     2      3          4          5
      msg_str = "Usage: keta_mesh_scan  H_st  H_end  num_H_pts  omega_st  del_omega"  
      #			   6              7        8      9	
      msg_str = msg_str "  num_omega_pts  sc_cnt   alpha  L " 
      print msg_str
      exit
    } 

    local H_st, H_en, num_H_pts, sc_cnt_time, omega_st, del_omega;
    local num_omega_pts, alp_val,L_val;
    H_st = $1;
    H_en = $2;
    num_H_pts = $3;
    omega_st = $4;
    del_omega = $5;
    num_omega_pts = $6
    sc_cnt_time = $7;
    alp_val = $8;
    L_val = $9;
   
    local d_H
    # calc delta
    if (num_H_pts < 1) {
       print " Error: Num points < 1 "
       exit
    }
    d_H = ($2 - $1)/(num_H_pts-1)
    
    # get current setmode, freeze, g_sect, and g_prefer parameters
    cur_mode1 = g_mode1
    cur_mode2 = g_mode2
    cur_mode3 = g_mode3
    cur_mode4 = g_mode4
    cur_mode5 = g_mode5

    # g_prefer = G[0] and g_sect = G[1]    
    g_sect_cur = G[1]
    g_prefer_cur = G[0]

    # ALPHA value
    old_alpha = ALPHA;
    p " OLD SETMODE = " g_mode1,g_mode2,g_mode3,g_mode4;
    p " OLD g_sect and g_prefer = " g_sect_cur,g_prefer_cur; 

    # set different modes
    # fphi and fchi GLOBAL
    setmode 0 2 3 4

    # freezing alpha,chi and phi 
    # freeze F_ALPHA F_CHI F_PHI
    g_frz = 1;
    F_ALPHA = alp_val;
    F_CHI = FLAT_CHI;
    F_PHI = FLAT_PHI;
    p " freeze alpha chi phi =" F_ALPHA, F_CHI, F_PHI;

    # save start motor positions arrays
    # H_ndx is no. of steps in H allowed for scanning
    H_ndx = 0;
    for(j=0;j<num_H_pts;j++) {
    	 H_val[j] = (H_st + j*d_H)
       H = H_val[j]; K = 0; L = L_val;
       g_sect = 0
	 g_prefer = 0
   	 calcA

       ## Do pre checking on the HKL range, possible Q range 
	 if (calcA){ 
		eprintf("(H K L = %g %g %g)\n",H,K,L)
	      print " Error: forbidden H K L"
            getangles

            # enter old values of modes and angles before exit
       	g_mode1 = cur_mode1; g_mode2 = cur_mode2;
       	g_mode3 = cur_mode3; g_mode4 = cur_mode4; 
		g_mode5 = cur_mode5;
       	g_frz = 0;
       	ALPHA = old_alpha;
       	freeze 
    	 	g_sect = g_sect_cur
       	g_prefer = g_prefer_cur
       	exit
       } 
 
     	 # for upper user limit "user(m, get_lim(m, 1))"
       # for upper dial limit of any motor(m) "get_lim(m, 1)" 
       # check both the limit of del,mu,keta

	 _bad_lim=0;
       _chk_lim del A[del]
       _chk_lim mu A[mu]
	 _chk_lim keta A[keta]
      if (_bad_lim) {
         eprintf("(H K L = %g %g %g)\n",H,K,L)

         # enter old values of modes and angles before exit
          g_mode1 = cur_mode1; g_mode2 = cur_mode2;
          g_mode3 = cur_mode3; g_mode4 = cur_mode4; g_mode5 = cur_mode5;
          g_frz = 0;
          ALPHA = old_alpha;
          freeze 
    	    g_sect = g_sect_cur;
          g_prefer = g_prefer_cur;
          exit
       } 
  
    
       # check upper limit of nu
       get_user_limit 4 1
       nu_upper_lim = user_limit
       if ( A[4] >= nu_upper_lim) {
          print " switch to nu --> nu -180"
          g_sect = 9
       }    
       calcA

       # check lower limit of  nu 
	 get_user_limit 4 -1
       nu_lower_lim = user_limit 
       if ( A[4] >= nu_lower_lim) {
          print " Now scanning step no = " H_ndx+1;
          print "( H K L ) = \n" H,K,L; 
          del_val[H_ndx]	= A[0]
          #eta_val[H_ndx] = A[1]
	    #chi_val[H_ndx] = A[2]
	    #phi_val[H_ndx] = A[3]
	    nu_val[H_ndx] = A[4]
	    mu_val[H_ndx] = A[5]
	    keta_val[H_ndx] = A[6] 
          #kap_val[H_ndx] = A[7]
	    #kphi_val[H_ndx] = A[8]
          H_ndx++;        
   	 }
    }
    	getangles
    
    # Important: Before running this macro check PHYSICALLY how OMEGA flips around cuts = -180 to 180

    # mv motors that only move once
    mv chi FLAT_CHI
    mv phi FLAT_PHI
       
    # do the scan 
    for(j=0;j<H_ndx;j++) {
       p " H STEP number = " j+1;
    
       # move to start for line on H
       mv del  del_val[j]
       mv nu   nu_cal[j]
       mv mu   mu_val[j]

       # note scan direction reverses line to line ie dont move keta
       # all the way back for the start of each line
       # keta_val[] are calc for (H_s,0,L)
       if ( (j+2 % 2) == 0) { 
              keta_st = keta_val[j] +  omega_st ;
              keta_en = keta_val[j] +  omega_st + del_omega;
       } else if ( (j+2 % 2) == 1) { 
              keta_st = keta_val[j] +  omega_st + del_omega ;
              keta_en = keta_val[j] +  omega_st ;
       } 
     
       # number of omega scan pts
       keta_pts = int(num_omega_pts*H_val[j]/H_st)
  
       # do the scan
       # check if HKL written do data file

       ### check to prevent omega flip at CUT_KETA (Q[34]) = -180
       xx = (fabs( CUT_KETA ) - fabs( keta_st ) );
       yy = (fabs( CUT_KETA ) - fabs( keta_en ) );
       if ( xx <= 0 ) {
          if ( keta_st < 0 ) { keta_st = keta_st + fabs(xx) + 1;
          }else {keta_st = keta_st - fabs(xx) -1;}
       }
       if ( yy <= 0 ) {
          if ( keta_en < 0 ) { keta_en = keta_en + fabs(yy) + 1;
          }else {keta_en = keta_en - fabs(yy) -1;}
       }
         	   
	 mv keta keta_st
       ascan keta keta_st keta_en keta_pts sc_cnt_time 	  
	  
    }
     
    # enter old values of modes and angles after scan
      g_mode1 = cur_mode1; g_mode2 = cur_mode2;
      g_mode3 = cur_mode3; g_mode4 = cur_mode4; g_mode5 = cur_mode5;
	ALPHA = old_alpha;
      freeze 
    	g_sect = g_sect_cur;
      g_prefer = g_prefer_cur;
}'

#################################################
# To get user_lim from dial_lim with proper sign
# One can get upper_lim with +1 and lower with -1
# when sign is -ve: limit reverses from upper to lower and vice versa
# but calculation USER = DIAL*SIGN + OFFSET remains the same
# checked with both positive and negative sign in the MEDM screen
global user_limit
def get_user_limit '{

    # check input
    if ($# != 2 ) {
      #                            		1          2      
      msg_str = "Usage: get_user_lim  motor_number  limit_direction +1/-1" 
      # limit_direction +1 is Upper/positive and -1 is lower/negative
      print msg_str
      exit
    } 
          
    motor_number = $1
    limit_dir = $2
    sign_dir = user(motor_number, 1) - user(motor_number, 0)
    #offset_val = user(motor_number, get_lim(motor_number,1))- sign_dir*get_lim(motor_number,1)
    if ( sign_dir > 0){limit_dir = limit_dir;}
       else{limit_dir = -limit_dir;}
    user_limit = user(motor_number, get_lim(motor_number, limit_dir))
}'

#################################################
# define surface OR using flat phi and chi for c
# and keta azimuth to define a along beam direction
#
def glass_or '{

  getangles      
  # check inputcab 1
  if ($# == 1 ) {
    # use input keta
    keta_azimuth = $1
  } else {
    # use current value
    print "Using current keta value as sample azimuth"
    keta_azimuth = A[6]
  } 

  # set lattice params
  setlat 1 1 1 90 90 90

  # reflections
  # or0
  g_h0=1		#  U[12], h
  g_k0=0		#  U[13], k 
  g_l0=0		#  U[14], l
  # or1
  g_h1=1		#  U[15], h
  g_k1=1		#  U[16], k
  g_l1=0		#  U[17], l

  # angle settings
  # or0
  g_u00=60		          #  U[18], del
  g_u01=keta_azimuth - 30   #  U[19], eta
  g_u02=FLAT_CHI 		    #  U[20], chi
  g_u03=FLAT_PHI		    #  U[21], phi
  g_u04=0		          #  U[22], nu
  g_u05=0		          #  U[23], mu
  # or1
  g_u10=90		          #  U[24], del
  g_u11=keta_azimuth + 45   #  U[25], eta
  g_u12=FLAT_CHI		    #  U[26], chi
  g_u13=FLAT_PHI	          #  U[27], phi
  g_u14=0		          #  U[28], nu
  g_u15=0		          #  U[29], mu
  
  # lambdas for ors
  g_lambda0=1.0	#  U[30], lambda or0 
  g_lambda1=1.0	#  U[31], lambda or1
 
  calcG		# calc(4) in geo code calc UB
  getE            # make sure have current LAMBDA
  calcHKL		# calc where we are from current motor settings (in A matrix)


}'
####################################################################################
# del scan at fixed alpha and beta ( Powder scan) 
#
def powder_scan '{

    # check input
    if ($# != 6 ) {
       #                    	  	  1       2        3      4              5       6  
       msg_str = "Usage: powder_scan  Q_st  Q_end  num_Q_pts  sc_cnt_time  alp_val  beta_val " 
       print msg_str
       exit
    } 
 
    local Q_st, Q_en, num_Q_pts, sc_cnt_time, alp_val,beta_val;
    Q_st = $1;
    Q_en = $2;
    num_Q_pts = $3;
    sc_time = $4;
    alp_val = $5;
    beta_val = $6;

    # for beta_val = 0, alp_val = beta_fix
    beta_fix = alp_val + beta_val
       
    # contstants
    lambda_val = LAMBDA;
    k_mod = 2*PI/lambda_val;
         
    # calc delta
    if (num_Q_pts < 1) {
        print " Error: Num points < 1 "
        exit
    }
    d_Q = ($2 - $1)/(num_Q_pts-1)

    # check the limits of mu
    _bad_lim=0;
    _chk_lim mu  alp_val	
    if (_bad_lim) {
        eprintf("(mu = %g )\n", mu)
        exit 
       }

     # save start motor positions arrays
     q_ndx = 0;
     qsft_ndx = 0;
     for(j=0;j<num_Q_pts;j++) {
     	   Q_val[j] = (Q_st + j*d_Q)
         print " now scanning step no. = " j+1;
         print " Q value = " Q_val[j];
 
         Q_ksq = pow(Q_val[j],2)/pow(k_mod,2)
         
         # calculate del_val[j]
         del_val[j] = asin(sqrt(Q_ksq(1-Q_ksq/4) - pow(sin(beta_fix),2)));
       
         # check the limits of del
	   _bad_lim=0;
         _chk_lim del del_val[j]
         if (_bad_lim) {
            eprintf("(del = %g %g )\n",del_val[j])
            exit
         }

         # calculate nu_val[j]
         nu_val[j] = asin( sin(beta_fix)/cos(del_val[j]));

        # check upper limit of nu
        get_user_limit nu 1
        nu_upper_lim = user_limit
        if ( nu_val[j] > nu_upper_lim) {
           #print " switch to nu --> nu -180"
           #print " switch to del --> 180 - del"
           print " at shift step number qsft_ndx = " qsft_ndx;
           nu_val[j] = nu_val[j] - 180
           del_val[j] = 180 - del_val[j]
           qsft_ndx++;
        }

        # check lower limit of  nu 
	  get_user_limit nu -1
        nu_lower_lim = user_limit 
        if ( nu_val[j] > nu_lower_lim) {
	      print " at step number q_ndx = " q_ndx;
            nu_val_mv[j] = nu_val[j] 
            q_ndx++;
        }
     } 
   getangles;
   # mv motors that only move once
   mv chi FLAT_CHI
   mv phi FLAT_PHI
   mv mu  alp_val
   mv keta A[keta]

   nu_st = asin(sin(beta_fix)/cos(del_st)));
   mv  nu  nu_st
   mv  del del_st
    
   # do all the printing stuffs
   # do all the initializations before trajectory if any!!!

   # Initialize trajectory
   traj_init

   # do the jrajector scan involving two motors
   # unlike hklscan (trajectory) with six motors

   # Define motors which will be moved
   # check for the right TRAJ_INDEX for del and nu
   _traj_move[del]=1
   _traj_move[nu]=1

   # Move to start of trajectory, remember positions
   get_angles; 
   scan_move

   # Build trajectory
   for (NPTS=0; NPTS < q_ndx; NPTS++) {
       _traj_pos[del][NPTS] = del_val[NPTS+1] - del_val[NPTS]
       _traj_pos[nu][NPTS] =  nu_val_mv[NPTS+1] - nu_val_mv[NPTS]

    }
    _traj_time[NPTS] = sc_time
    
    traj_build q_ndx q_ndx
    
    # Execute trajectory
    traj_exec
    
    # Read counts
    traj_read_counts COUNTERS q_ndx
    
    # If TRAJ_USE_ACTUAL is true then read actual positions
    if (TRAJ_USE_ACTUAL) traj_read_actual _n1
    
     # Print, save and plot results
    for (NPTS=0; NPTS < q_ndx; NPTS++) {
        if (TRAJ_USE_ACTUAL) {
            if (all_real) {
                for (i=0;i<_nm;i++) 
                    A[_m[i]] = _traj_actual[_traj_motor[i]][NPTS]
             } else {
                for (i=0;i<MAX_TRAJ_INDEX;i++) {
                    k = TRAJ_INDEX[i]
                    if (k < 0) continue
                    A[i] = _traj_actual[k][NPTS]
                }

     }
	
}'

####################################################################################
# check powder scan for allowed Q range 
# for two different sectors g_sect = 0 and g_sect= 9
# where nu reaches it's upper and lower limit
def check_powder_scan '{

    # check input
    if ($# != 6 ) {
       #                           	  	  1       2        3      4         5       6  
       msg_str = "Usage: check_powder_scan  Q_st  Q_end  num_Q_pts  sc_cnt  alp_val  beta_val " 
       msg_str2 = " angles are in degree to be converted to radian before trigonometric operations"
       print msg_str
       print msg_str2
       exit
    } 
 
    local Q_st, Q_en, num_Q_pts, sc_cnt_time, alp_val,beta_val;
    Q_st = $1;
    Q_en = $2;
    num_Q_pts = $3;
    sc_cnt_time = $4;
    alp_val = $5;
    beta_val = $6;

    # contstants
    degree = 180/PI;
    radian = PI/180;
    lambda_val = LAMBDA;
    k_mod = 2*PI/lambda_val;
    print " k_mod = " k_mod;

    # for beta_val = 0, alp_val = beta_fix
    beta_fix = (alp_val + beta_val)*radian
         
    # calc delta
    if (num_Q_pts < 1) {
        print " Error: Num points < 1 "
        exit
    }
    d_Q = ($2 - $1)/(num_Q_pts-1)

    # check the limits of mu
    _bad_lim=0;
    _chk_lim mu  alp_val	
    if (_bad_lim) {
        eprintf("(mu = %g )\n", alp_val)
        exit 
       }

     # save start motor positions arrays
     local Q_ksq;
     q_ndx = 0;
     qsft_ndx = 0;
     for(j=0;j<num_Q_pts;j++) {
     	   Q_val[j] = (Q_st + j*d_Q)
         print " now scanning step no. = " j+1;
         print " Q value = " Q_val[j];
         if ( Q_val[j] >= 2 * k_mod ){ 
            print " Q_val > Q_max = " Q_val[j];
            exit
         }
          Q_ksq = pow(Q_val[j], 2)/pow(k_mod, 2)
          print" Q_ksq value = " Q_ksq;
          print" calculating del_val"

         # calculate del_val[j]
         del_val[j] =  asin(sqrt(Q_ksq*(1 - Q_ksq/4.0) - pow(sin(beta_fix), 2)))*degree;
	   
	   #del_val reduces beyond ( 90 - beta_fix) angle for increase in Q_val 
         if ( Q_ksq >= 2 ) {
            print " Q_ksq >= 2, switch to del --> 180 - del"
            del_val[j] = 180 - del_val[j];
         }
	
         # check the limits of del
	   _bad_lim=0;
         _chk_lim del del_val[j]
         if (_bad_lim) {
            eprintf("(del = %g )\n",del_val[j])
            exit
         }
          print" calculating nu_val"
         # calculate nu_val[j]
         nu_val[j] = asin( sin(beta_fix)/cos(del_val[j]*radian))*degree;

        # check upper limit of nu
        get_user_limit nu 1
        nu_upper_lim = user_limit
        if ( nu_val[j] > nu_upper_lim) {
           qsft_ndx++;
           print " reaching nu_upper_limit for nu_val =\n " nu_val[j];
           print " for del_val = " del_val[j];
           print " for Q_val = " Q_val[j];
           print " at step number qsft_ndx = " qsft_ndx;
           print " switching to g_sect = 9 "
           print " switch to nu --> nu -180"
           print " switch to del --> 180 - del"
           
           nu_val[j] = nu_val[j] - 180
           del_val[j] = 180 - del_val[j]
           Q_shift[qsft_ndx] = Q_val[j]; 
       }

        # check lower limit of  nu 
	  get_user_limit nu -1
        nu_lower_lim = user_limit 
        if ( nu_val[j] < nu_lower_lim) {
	      print " reaching nu_lower_limit for nu_val = " nu_val[j];
            q_ndx++;
            print " for del_val = " del_val[j];
            print " for Q_val = " Q_val[j];
            print " at step number q_ndx = " q_ndx;

            Q_fbdn[q_ndx] = Q_val[j];
        }
        print " del value = " del_val[j];
        print " nu value = " nu_val[j];

     }
     print " **************************************************\n "
     print " Q_shift_start [1] = " Q_shift[1];  
     print " Q_shift_end [qsft_ndx] = " Q_shift[qsft_ndx];
     print " total number of steps shifted = " qsft_ndx;  
     print " --------------------------------------------------\n "
     print " Q_fbdn_start [1] = " Q_fbdn[1];  
     print " Q_fbdn_end [q_ndx] = " Q_fbdn[q_ndx];
     print " total number of steps forbidden = " q_ndx;  

 }'


